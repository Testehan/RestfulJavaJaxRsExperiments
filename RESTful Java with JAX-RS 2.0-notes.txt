        RESTful Java with JAX-RS 2.0 - Designing and Developing distributed webservices

Introduction/Preface

REST is an architectural style that defines a set of constraints that, when applied to the
architecture of a distributed system, induce desirable properties like loose coupling and
horizontal scalability. RESTful web services are the result of applying these constraints
to services that utilize web standards such as URIs, HTTP, XML, and JSON. Such serv‐
ices become part of the fabric of the Web and can take advantage of years of web engi‐
neering to satisfy their clients’ needs.

The Java API for RESTful web services (JAX-RS) is a new API that aims to make
development of RESTful web services in Java simple and intuitive. The initial impetus
for the API came from the observation that existing Java Web APIs were generally either:
    • Very low level, leaving the developer to do a lot of repetitive and error-prone work
    such as URI parsing and content negotiation, or
    • Rather high level and proscriptive, making it easy to build services that conform to
    a particular pattern but lacking the necessary flexibility to tackle more general
    problems.

JAX-RS is one of the latest generations of Java APIs that make use of Java annotations
to reduce the need for standard base classes, implementing required interfaces, and outof-band configuration files.

!!!!
Annotations are used to route client requests to matching Java class methods and declaratively map request data to
the parameters of those methods.

Bill Burke led the development of one of the JAX-RS implementations mentioned earlier
(RESTEasy) and was an active and attentive member of the expert group.

This book, RESTful Java with JAX-RS 2.0, provides an in-depth tutorial on JAX-RS and
shows how to get the most from this new API while adhering to the REST architectural
style. I hope you enjoy the book and working with JAX-RS.


Who Should Read This Book
    This book teaches you how to design and develop distributed web services in Java using
    RESTful architectural principles on top of the HTTP protocol. It is mostly a compre‐
    hensive reference guide on the JAX-RS specification, which is a JCP standardized an‐
    notation framework for writing RESTful web services in Java.

    While this book does go into many of the fundamentals of REST, it does not cover them
    all and focuses more on implementation rather than theory. You can satisfy your craving
    for more RESTful theory by obtaining RESTful Web Services by Leonard Richardson
    and Sam Ruby (O’Reilly). If you are familiar with writing Java EE applications, you will
    be very comfortable reading this book

    Before reading this book, you should also be fairly fluent in the Java language and
    specifically know how to use and apply Java annotations

How This Book Is Organized  !!!!
    This book is organized into two parts: the technical manuscript, followed by the JAXRS workbook.
    The technical manuscript explains what REST and JAX-RS are, how they
    work, and when to use them. The JAX-RS workbook provides step-by-step instructions
    for installing, configuring, and running the JAX-RS examples from the manuscript with
    the JBoss RESTEasy framework, an implementation of JAX-RS.


===============================================================================================================
===============================================================================================================
Part 1 - REST and the JAX-RS Standard

===============================================================================================================
CHAPTER 1 - Introduction to REST

    Really, most of us take the Web for granted. Have you, as a programmer, sat down and
    tried to understand why the Web has been so successful? How has it grown from a simple
    network of researchers and academics to an interconnected worldwide community?
    What properties of the Web make it so viral?

    One man, Roy Fielding, did ask these questions in his doctoral thesis, “Architectural
    Styles and the Design of Network-based Software Architectures.”
    In it, he identifies specific architectural principles that answer the following questions:
        • Why is the Web so prevalent and ubiquitous?
        • What makes the Web scale?
        • How can I apply the architecture of the Web to my own applications?

!!!!!
    The set of these architectural principles is called REpresentational State Transfer (REST)
    and is defined as:
        Addressable resources
            The key abstraction of information and data in REST is a resource, and each re‐
            source must be addressable via a URI (Uniform Resource Identifier).
        A uniform, constrained interface
            Use a small set of well-defined methods to manipulate your resources.
        Representation-oriented
            You interact with services using representations of that service. A resource refer‐
            enced by one URI can have different formats. Different platforms need different
            formats. For example, browsers need HTML, JavaScript needs JSON (JavaScript
            Object Notation), and a Java application may need XML.
        Communicate statelessly
            Stateless applications are easier to scale.
        Hypermedia As The Engine Of Application State (HATEOAS)
            Let your data formats drive state transitions in your applications.

    For a PhD thesis, Fielding’s paper is actually very readable and, thankfully, not very long.
    It, along with Leonard Richardson and Sam Ruby’s book RESTful Web APIs (O’Reilly),
    is an excellent reference for understanding REST


    REST and the Rebirth of HTTP
        REST isn’t protocol-specific, but when people talk about REST, they usually mean REST over HTTP.

 !!     Browser-based web applications see only a tiny fraction of the features of HTTP

 !!     HTTP is actually a very rich application protocol that provides a multitude of interesting and useful
        capabilities for application developers. You will need a good understanding of HTTP in order to write
        RESTful web services.

        HTTP is a synchronous request/response-based application network protocol used for
        distributed, collaborative, document-based systems. It is the primary protocol used on the Web

         The protocol is very simple: the client sends a request message made up of
         the HTTP method being invoked, the location of the resource you are interested in
         invoking, a variable set of headers, and an optional message body that can basically be
         anything you want, including HTML, plain text, XML, JSON, and even binary data.

        Here’s an example:
            GET /resteasy HTTP/1.1
            Host: jboss.org
            User-Agent: Mozilla/5.0
            Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
            Accept-Language: en-us,en;q=0.5
            Accept-Encoding: gzip,deflate

        Here’s the message the server might respond with using the previous GET query:
            HTTP/1.1 200 OK
            X-Powered-By: Servlet 2.4; JBoss-4.2.2.GA
            Content-Type: text/html
            <head>
            <title>JBoss RESTEasy Project</title>
            </head>
            <body>
            <h1>JBoss RESTEasy</h1>
            <p>JBoss RESTEasy is an open source implementation of the JAX-RS specification...


    RESTful Architectural Principles
        programmers started to realize that they could use the concepts of REST to build dis‐
        tributed services and model service-oriented architectures (SOAs).

        The idea of SOA is that application developers design their systems as a set of reusable,
        decoupled, distributed services. Since these services are published on the network, con‐
        ceptually, it should be easier to compose larger and more complex systems. SOA has
        been around for a long time. Developers have used technologies like DCE, CORBA, and
        Java RMI to build them in the past. Nowadays, though, when you think of SOA, you
        think of SOAP-based web services.

        While REST has many similarities to the more traditional ways of writing SOA appli‐
        cations, it is very different in many important ways. You would think that a background
        in distributed computing would be an asset to understanding this new way of creating
        web services, but unfortunately this is not always the case. The reason is that some of
        the concepts of REST are hard to swallow, especially if you have written successful SOAP
        or CORBA applications. If your career has a foundation in one of these older technol‐
        ogies, there’s a bit of emotional baggage you will have to overcome.

        Let’s examine each of the architectural principles of REST in detail and why they are
        important when you are writing a web service:


    1.Addressability
        Addressability is the idea that every object and resource in your system is reachable
        through a unique identifier.

 !!!    In the REST world, addressability is managed through the use of URIs. When you make
        a request for information in your browser, you are typing in a URI. Each HTTP request
        must contain the URI of the object you are requesting information from or posting
        information to. The format of a URI is standardized as follows:

            scheme://host:port/path?queryString#fragment

        The scheme is the protocol you are using to communicate with. For RESTful web serv‐
        ices, it is usually http or https. The host is a DNS name or IP address. It is followed
        by an optional port, which is numeric. The host and port represent the location of
        your resource on the network. Following host and port is a path expression. This path
        expression is a set of text segments delimited by the “/” character. Think of the path
        expression as a directory list of a file on your machine

        Following the path expression is an optional query string. The “?” character separates the path from the
        query string.
        The query string is a list of parameters represented as name/value pairs. Each pair is
        delimited with the “&” character. Here’s an example query string within a URI:

            http://example.com/customers?lastName=Burke&zipcode=02115

        The last part of the URI is the fragment. It is delimited by a “#” character. The fragment
        is usually used to point to a certain place in the document you are querying.

 !!     Not all characters are allowed within a URI string. Some characters must be encoded
        using the following rules. The characters a–z, A–Z, 0–9, ., -, *, and _ remain the same.
        The space character is converted to +. The other characters are first converted into a
        sequence of bytes using a specific encoding scheme. Next, a two-digit hexadecimal
        number prefixed by % represents each byte.

        Using a unique URI to identify each of your services makes each of your resources
        linkable. Service references can be embedded in documents or even email messages.
        For instance, consider the situation where somebody calls your company’s help desk
        with a problem related to your SOA application. A link could represent the exact prob‐
        lem the user is having. Customer support can email the link to a developer who can fix
        the problem


    2.The Uniform, Constrained Interface
        The idea behind it is that you stick to the finite set of operations of the application protocol you’re
        distributing your services upon.
        This means that you don’t have an “action” parameter in your URI and use only the
        methods of HTTP for your web services. HTTP has a small, fixed set of operational methods. Each method has a
        specific purpose and meaning.

            GET
                GET is a read-only operation. It is used to query the server for specific information.
                It is both an idempotent and safe operation. Idempotent means that no matter how
                many times you apply the operation, the result is always the same. The act of reading
                an HTML document shouldn’t change the document. Safe means that invoking a
                GET does not change the state of the server at all. This means that, other than request
                load, the operation will not affect the server.

            PUT
                PUT requests that the server store the message body sent with the request under
                the location provided in the HTTP message. It is usually modeled as an insert or
                update. It is also idempotent. When using PUT, the client knows the identity of the
                resource it is creating or updating. It is idempotent because sending the same PUT
                message more than once has no effect on the underlying service. An analogy is an
                MS Word document that you are editing. No matter how many times you click the
                Save button, the file that stores your document will logically be the same document

            DELETE
                DELETE is used to remove resources. It is idempotent as well.

            POST
                POST is the only nonidempotent and unsafe operation of HTTP. Each POST meth‐
                od is allowed to modify the service in a unique way. You may or may not send
                information with the request. You may or may not receive information from the response.

            HEAD
                HEAD is exactly like GET except that instead of returning a response body, it re‐
                turns only a response code and any headers associated with the request.

            OPTIONS
                OPTIONS is used to request information about the communication options of the
                resource you are interested in. It allows the client to determine the capabilities of a
                server and a resource without triggering any resource action or retrieval.

        Constraining the interface for your web services has many more advantages than dis‐
        advantages. Let’s look at a few:
            Familiarity
                If you have a URI that points to a service, you know exactly which methods are
                available on that resource. You don’t need an IDL-like file describing which methods
                are available. You don’t need stubs. All you need is an HTTP client library. If you
                have a document that is composed of links to data provided by many different
                services, you already know which method to call to pull in data from those links.

            Interoperability
                HTTP is a very ubiquitous protocol. Most programming languages have an HTTP
                client library available to them. So, if your web service is exposed over HTTP, there
                is a very high probability that people who want to use your service will be able to
                do so without any additional requirements beyond being able to exchange the data
                formats the service is expecting. With CORBA or SOAP, you have to install vendor specific client
                libraries as well as loads and loads of IDL- or WSDL-generated stub code.

                With REST over HTTP, you don’t have to worry about either of these
                things and can just focus on understanding the data format of the service. I like to
                think that you are focusing on what is really important: application interoperability, rather
                than vendor interoperability.

            Scalability
                Because REST constrains you to a well-defined set of methods, you have predictable
                behavior that can have incredible performance benefits. GET is the strongest ex‐
                ample. When surfing the Internet, have you noticed that the second time you browse
                to a specific page it comes up faster? This is because your browser caches already
                visited pages and images. HTTP has a fairly rich and configurable protocol for
                defining caching semantics. Because GET is a read method that is both idempotent
                and safe, browsers and HTTP proxies can cache responses to servers, and this can
                save a huge amount of network traffic and hits to your website


    3.Representation-Oriented
        The third architectural principle of REST is that your services should be representationoriented.
        Each service is addressable through a specific URI and representations are
        exchanged between the client and service. With a GET operation, you are receiving a
        representation of the current state of that resource. A PUT or POST passes a represen‐
        tation of the resource to the server so that the underlying resource’s state can change.

        These representations could be XML, JSON, YAML, or really any format you can come up with.

        HTTP uses the Content-Type header to tell the client or server what data format it is receiving.
        The Content-Type header value string is in the Multipurpose Internet Mail Extension (MIME) format

        The MIME format is very simple:
            type/subtype;name=value;name=value...
        type is the main format family and subtype is a category. Optionally, the MIME type
        can have a set of name/value pair properties delimited by the “;” character. Some examples are:
            text/plain
            text/html
            application/xml
            text/html; charset=iso-8859-1

 !!!!   While not used very much by your browser, HTTP content negotiation is a very pow‐
        erful tool when you’re writing web services. With the Accept header, a client can list its
        preferred response formats. Ajax clients can ask for JSON, Java for XML, Ruby for
        YAML. Another thing this is very useful for is versioning of services. The same service
        can be available through the same URI with the same methods (GET, POST, etc.), and
        all that changes is the MIME type. For example, the MIME type could be application/
        vnd+xml for an old service, while newer services could exchange application/vnd
        +xml;version=1.1 MIME types

        All in all, because REST and HTTP have a layered approach to addressability, method
        choice, and data format, you have a much more decoupled protocol that allows your
        service to interact with a wide variety of clients in a consistent way.


    4.Communicate Statelessly
!!!!!   The fourth RESTful principle I will discuss is the idea of statelessness. When I talk about
        statelessness, though, I don’t mean that your applications can’t have state. In REST,
        stateless means that there is no client session data stored on the server. The server only
        records and manages the state of the resources it exposes. If there needs to be session specific data, it
        should be held and maintained by the client and transferred to the server
        with each request as needed. A service layer that does not have to maintain client sessions
        is a lot easier to scale, as it has to do a lot fewer expensive replications in a clustered
        environment. It’s a lot easier to scale up because all you have to do is add machines.

!!!     A world without server-maintained session data isn’t so hard to imagine if you look
        back 12–15 years ago. Back then, many distributed applications had a fat GUI client
        written in Visual Basic, Power Builder, or Visual C++ talking RPCs to a middle tier that
        sat in front of a database. The server was stateless and just processed data. The fat client
        held all session state. The problem with this architecture was an IT operations one. It
        was very hard for operations to upgrade, patch, and maintain client GUIs in large en‐
        vironments. Web applications solved this problem because the applications could be
        delivered from a central server and rendered by the browser. We started maintaining
        client sessions on the server because of the limitations of the browser. Around 2008, in
        step with the growing popularity of Ajax, Flex, and Java FX, the browsers became so‐
        phisticated enough to maintain their own session state like their fat-client counterparts
        in the mid-’90s used to do. We can now go back to that stateless scalable middle tier that
        we enjoyed in the past. It’s funny how things go full circle sometimes


    5. HATEOAS
        The final principle of REST is the idea of using Hypermedia As The Engine Of Appli‐
        cation State (HATEOAS). Hypermedia is a document-centric approach with added
        support for embedding links to other services and information within that document format.

            <order id="111">
             <customer>http://customers.myintranet.com/customers/32133</customer>
             <order-entries>
              <order-entry>
              <quantity>5</quantity>
              <product>http://products.myintranet.com/products/111</product>
              ...

        In that example, links embedded within the document allowed us to bring in additional
        information as needed. Aggregation isn’t the full concept of HATEOAS, though. The
        more interesting part of HATEOAS is the “engine.”

        HATEOAS is a bit different because with each request returned from a server it tells you what new
        interactions you can do next, as well as where to go to transition the state of your applications.

        For example, let’s say we wanted to get a list of products available on a web store. We do
        an HTTP GET on http://example.com/webstore/products and receive back:
            <products>
             <product id="123">
             <name>headphones</name>
             <price>$16.99</price>
             </product>
             <product id="124">
             <name>USB Cable</name>
             <price>$5.99</price>
             </product>
            ...
            </products>
        This could be problematic if we had thousands of products to send back to our client.
        We might overload it, or the client might wait forever for the response to finish down‐
        loading. We could instead list only the first five products and provide a link to get the
        next set:
            <products>
             <link rel="next" href="http://example.com/store/products?startIndex=5"/>
             <product id="123">
             <name>headphones</name>
             <price>$16.99</price>
             </product>
             ...
            </products>

        Following the next link could get them back a new document with additional links:
            <products>
             <link rel="previous" href="http://example.com/store/products?startIndex=0"/>
             <link rel="next" href="http://example.com/webstore/products?startIndex=10"/>
             <product id="128">
             <name>stuff</name>
             <price>$16.99</price>
             </product>
            ...
            </products>

===============================================================================================================
CHAPTER 2 - Designing RESTful Services

    So, let’s define a RESTful interface for a simple order entry
    system of a hypothetical ecommerce web store. Remote distributed clients will use this
    web service to purchase goods, modify existing orders in the system, and view infor‐
    mation about customers and products.

    To satisfy the addressability requirements of REST, we will first have to define a set of URIs that represent the
    entry points into our system. Since RESTful systems are representation-oriented, we
    will next define the data format that we will use to exchange information between our
    services and clients. Finally, we will decide which HTTP methods are allowed by each
    exposed URI and what those methods do. We will make sure to conform to the uniform,
    constrained interface of HTTP when doing this step.


    The object model
        see the pic "1 - Object model - used in the examples from the book.png"


!!! Model the URIs
        The first thing we are going to do to create our distributed interface is define and name
        each of the distributed endpoints in our system. In a RESTful system, endpoints are
        usually referred to as resources and are identified using a URI. URIs satisfy the address‐
        ability requirements of a RESTful service.

        In our object model, we will be interacting with Orders, Customers, and Products.
        These will be our main, top-level resources. We want to be able to obtain lists of each
        of these top-level items and to interact with individual items. LineItems are aggregated
        within Order objects so they will not be a top-level resource. We could expose them as
        a subresource under one particular Order, but for now, let’s assume they are hidden by
        the data format.

        Given this, here is a list of URIs that will be exposed in our system:
            /orders
            /orders/{id}
            /products
            /products/{id}
            /customers
            /customers/{id}

 !!!    You’ll notice that the nouns in our object model have been represented as URIs.
        URIs shouldn’t be used as mini-RPC mechanisms and should not identify operations.
        Instead, you should use a combination of HTTP methods and the data format to model unique opera‐
        tions in your distributed RESTful system.


    Defining the Data Format
        One of the most important things we have to do when defining a RESTful interface is
        determine how our resources will be represented over the wire to our clients. XML is
        perhaps one of the most popular formats on the Web and can be processed by most
        modern languages, so let’s choose that. JSON is also a popular format, as it is more
        condensed and JavaScript can interpret it directly (great for Ajax applications), but let’s
        stick to XML for now.

        Generally, you would define an XML schema for each representation you want to send
        across the wire. An XML schema defines the grammar of a data format. It defines the
        rules about how a document can be put together.


    Read and Update Format
        Each format for Order, Customer, and Product will have a common XML element called link:
            <link rel="self" href="http://example.com/..."/>
        The link element tells any client that obtains an XML document describing one of the
        objects in our ecommerce system where on the network the client can interact with that
        particular resource. The rel attribute tells the client what relationship the link has with
        the resource the URI points to (contained within the href attribute).

        The self value just means it is pointing to itself. While not that interesting on its own, link becomes
        very useful when we aggregate or compose information into one larger XML document.

        So, with the common elements described, let’s start diving into the details by first looking
        at our Customer representation format:
            <customer id="117">
             <link rel="self" href="http://example.com/customers/117"/>
             <first-name>Bill</first-name>
             <last-name>Burke</last-name>
             <street>555 Beacon St.<street>
             <city>Boston</city>
             <state>MA</state>
             <zip>02115</zip>
            </customer>
        Pretty straightforward. We just take the object model of Customer from Figure 2-1 (Object model printscreen)
        and expand its attributes as XML elements.

            <product id="543">
             <link rel="self" href="http://example.com/products/543"/>
             <name>iPhone</name>
             <cost>$199.99</cost>
            </product>

            <order id="233">
             <link rel="self" href="http://example.com/orders/233"/>
             <total>$199.02</total>
             <date>December 22, 2008 06:56</date>
             <customer id="117">
                <link rel="self" href="http://example.com/customers/117"/>
                ...
             </customer>
             <line-items>
                 <line-item id="144">
                     <product id="543">
                        <link rel="self" href="http://example.com/products/543"/>
                        ...
                     </product>
                     <quantity>1</quantity>
                 </line-item>
              </line-items>
             </order>

        Order is a great example of data composition, as it includes Customer and Product information.
        This is where the link element becomes particularly useful. If the client is interested in interacting with a
        Customer or Product that makes up the Order, it has the URI needed to interact with
        one of these resources.


    Create Format
        When we are creating new Orders, Customers, or Products, it doesn’t make a lot of
        sense to include an id attribute and link element with our XML document. The server
        will generate IDs when it inserts our new object into a database. We also don’t know the
        URI of a new object because the server also generates this. So, the XML for creating a
        new Product would look something like this:
            <product>
             <name>iPhone</name>
             <cost>$199.99</cost>
            </product>


    Assigning HTTP Methods
!!!!    The final thing we have to do is decide which HTTP methods will be exposed for each
        of our resources and what these methods will do. It is crucial that we do not assign
        functionality to an HTTP method that supersedes the specification-defined boundaries
        of that method. For example, an HTTP GET on a particular resource should be readonly.
        It should not change the state of the resource it is invoking on. Intermediate services
        like a proxy-cache, a CDN (Akamai), or your browser rely on you to follow the semantics
        of HTTP strictly so that they can perform built-in tasks like caching effectively


    Browsing All Orders, Customers, or Products
        The Order, Customer, and Product objects in our object model are all very similar in
        how they are accessed and manipulated. One thing our remote clients will want to do
        is to browse all the Orders, Customers, or Products in the system. These URIs represent
        these objects as a group:
            /orders
            /products
            /customers

        To get a list of Orders, Products, or Customers, the remote client will call an HTTP
        GET on the URI of the object group it is interested in
        Our service will respond with a data format that represents all Orders, Products, or
        Customers within our system

            HTTP/1.1 200 OK
            Content-Type: application/xml

            <products>
             <product id="111">
             <link rel="self" href="http://example.com/products/111"/>
             <name>iPhone</name>
             <cost>$199.99</cost>
             </product>
             <product id="222">
             <link rel="self" href="http://example.com/products/222"/>
             <name>Macbook</name>
             <cost>$1599.99</cost>
             </product>
            ...
            </products>

!!!!    One problem with this bulk operation is that we may have thousands of Orders, Customers, or
        Products in our system and we may overload our client and hurt our response
        times. To mitigate this problem, we will allow the client to specify query parameters on
        the URI to limit the size of the dataset returned:

            GET /orders?startIndex=0&size=5 HTTP/1.1

 !!     Here we have defined two query parameters: startIndex and size. The startIndex
        parameter represents where in our large list of Orders, Products, or Customers we want
        to start sending objects from. It is a numeric index into the object group being queried.
        The size parameter specifies how many of those objects in the list we want to return.
        These parameters will be optional. The client does not have to specify them in its URI
        when crafting its request to the server


    Obtaining Individual Orders, Customers, or Products
        I mentioned in the previous section that we would use a URI pattern to obtain individual
        Orders, Customers, or Products:
            /orders/{id}
            /products/{id}
            /customers/{id}
        We will use the HTTP GET method to retrieve individual objects in our system. Each
        GET invocation will return a data format that represents the object being obtained:
            GET /orders/233 HTTP/1.1


    Creating an Order, Customer, or Product
        There are two possible ways in which a client could create an Order, Customer, or
        Product within our order entry system: by using either the HTTP PUT or POST meth‐
        od. Let’s look at both ways

        Creating with PUT
            The HTTP definition of PUT states that it can be used to create or update a resource
            on the server. To create an Order, Customer, or Product with PUT, the client simply
            sends a representation of the new object it is creating to the exact URI location that
            represents the object:
                PUT /orders/233 HTTP/1.1
                PUT /customers/112 HTTP/1.1
                PUT /products/664 HTTP/1.1
            PUT is required by the specification to send a response code of 201, “Created,” if a new
            resource was created on the server as a result of the request.

            The HTTP specification also states that PUT is idempotent. Our PUT is idempotent,
            because no matter how many times we tell the server to “create” our Order, the same
            bits are stored at the /orders/233 location

  !!!!      The disadvantage of using PUT to create resources is that the client has to provide the
            unique ID that represents the object it is creating. While it usually possible for the client
            to generate this unique ID, most application designers prefer that their servers (usually
            through their databases) create this ID. In our hypothetical order entry system, we want
            our server to control the generation of resource IDs. So what do we do? We can switch
            to using POST instead of PUT.

    Creating with POST
        Creating an Order, Customer, or Product using the POST method is a little more com‐
        plex than using PUT. To create an Order, Customer, or Product with POST, the client
        sends a representation of the new object it is creating to the parent URI of its represen‐
        tation, leaving out the numeric target ID. For example:
            POST /orders HTTP/1.1
            Content-Type: application/xml
            <order>
             <total>$199.02</total>
             <date>December 22, 2008 06:56</date>
            ...
            </order>
        The service receives the POST message, processes the XML, and creates a new order in
        the database using a database-generated unique ID. While this approach works perfectly
        fine, we’ve left our client in a quandary. What if the client wants to edit, update, or cancel
        the order it just posted? What is the ID of the new order? What URI can we use to
        interact with the new resource? To resolve this issue, we will add a bit of information to
        the HTTP response message

        The client would receive a message something like this:
            HTTP/1.1 201 Created
            Content-Type: application/xml
            Location: http://example.com/orders/233
            <order id="233">
             <link rel="self" href="http://example.com/orders/233"/>
             <total>$199.02</total>
             <date>December 22, 2008 06:56</date>
            ...
            </order>

  !!!   HTTP requires that if POST creates a new resource, it respond with a code of 201,
        “Created” (just like PUT). The Location header in the response message provides a URI
        to the client so it knows where to further interact with the Order that was created (i.e.,
        if the client wanted to update the Order). It is optional whether the server sends the
        representation of the newly created Order with the response. Here, we send back an
        XML representation of the Order that was just created with the ID attribute set to the
        one generated by our database as well as a link element.


    Updating an Order, Customer, or Product
        We will model updating an Order, Customer, or Product using the HTTP PUT method.
        The client PUTs a new representation of the object it is updating to the exact URI location
        that represents the object

        When a resource is updated with PUT, the HTTP specification requires that you send
        a response code of 200, “OK,” and a response message body or a response code of 204,
        “No Content,” without any response body. In our system, we will send a status of 204
        and no response message.


    Removing an Order, Customer, or Product
!!!!    We will model deleting an Order, Customer, or Product using the HTTP DELETE
        method. The client simply invokes the DELETE method on the exact URI that represents
        the object we want to remove. Removing an object will wipe its existence from the system.

        When a resource is removed with DELETE, the HTTP specification requires that you
        send a response code of 200, “OK,” and a response message body or a response code of
        204, “No Content,” without any response body. In our application, we will send a status
        of 204 and no response message.


    Cancelling an Order
!!!     So far, the operations of our object model have fit quite nicely into corresponding HTTP
        methods. We’re using GET for reading, PUT for updating, POST for creating, and
        DELETE for removing. We do have an operation in our object model that doesn’t fit so
        nicely. In our system, Orders can be cancelled as well as removed. While removing an
        object wipes it clean from our databases, cancelling only changes the state of the Order
        and retains it within the system. How should we model such an operation?
 !!!    Overloading the meaning of DELETE

        Cancelling an Order is very similar to removing it. Since we are already modeling re‐
        move with the HTTP DELETE method, one thing we could do is add an extra query
        parameter to the request:
            DELETE /orders/233?cancel=true

        Here, the cancel query parameter would tell our service that we don’t really want to
        remove the Order, but cancel it. In other words, we are overloading the meaning of DELETE.

 !!!!   While I’m not going to tell you not to do this, I will tell you that you shouldn’t do it. It
        is not good RESTful design. In this case, you are changing the meaning of the uniform
        interface. Using a query parameter in this way is actually creating a mini-RPC mecha‐
        nism. HTTP specifically states that DELETE is used to delete a resource from the server,
        not cancel it

    States versus operations
        When modeling a RESTful interface for the operations of your object model, you should
        ask yourself a simple question: is the operation a state of the resource? If you answer
        yes to this question, the operation should be modeled within the data format.
        Cancelling an Order is a perfect example of this. The key with cancelling is that it is a
        specific state of an Order. When a client follows a particular URI that links to a specific
        Order, the client will want to know whether the Order was cancelled or not.

        Information about the cancellation needs to be in the data format of the Order.
        So let’s add a cancelled element to our Order data format:
            <order id="233">
             <link rel="self" href="http://example.com/orders/233"/>
             <total>$199.02</total>
             <date>December 22, 2008 06:56</date>
             <cancelled>false</cancelled>
            ...
            </order>
        Since the state of being cancelled is modeled in the data format, we can now use our
        already defined mechanism of updating an Order to model the cancel operation. For
        example, we could PUT this message to our service

 !!!!   This pattern of modeling an operation as the state of the resource doesn’t always fit,
        though. What if we expanded on our cancel example by saying that we wanted a way to
        clean up all cancelled orders? In other words, we want to purge all cancelled orders from
        our database. We can’t really model purging the same way we did cancel. While purge
        does change the state of our application, it is not in and of itself a state of the application.
        To solve this problem, we model this operation as a subresource of /orders and we
        trigger a purging by doing a POST on that resource. For example:
            POST /orders/purge HTTP/1.1


    Wrapping Up
        So, we’ve taken an existing object diagram and modeled it as a RESTful distributed
        service. We used URIs to represent the endpoints in our system. These endpoints are
        called resources. For each resource, we defined which HTTP methods each resource
        will allow and how those individual HTTP methods behave. Finally, we defined the data
        format that our clients and services will use to exchange information. The next step is
        to actually implement these services in Java. This will be the main topic for the rest of
        this book

===============================================================================================================
CHAPTER 3 - Your First JAX-RS Service

!!  Writing RESTful services in Java has been possible for years with the servlet API. If you
    have written a web application in Java, you are probably already very familiar with
    servlets. Servlets bring you very close to the HTTP protocol and require a lot of boil‐
    erplate code to move information to and from an HTTP request. In 2008, a new spec‐
    ification called JAX-RS was defined to simplify RESTful service implementation.

    JAX-RS is a framework that focuses on applying Java annotations to plain Java objects.
    It has annotations to bind specific URI patterns and HTTP operations to individual
    methods of your Java class. It has parameter injection annotations so that you can easily
    pull in information from the HTTP request. It has message body readers and writers
    that allow you to decouple data format marshalling and unmarshalling from your Java
    data objects. It has exception mappers that can map an application-thrown exception
    to an HTTP response code and message. Finally, it has some nice facilities for HTTP
    content negotiation


    Developing a JAX-RS RESTful Service
        Specifically, we’ll define a JAX-RS service that allows us to read, create,
        and update Customers. To do this, we will need to implement two Java classes. One class
        will be used to represent actual Customers. The other will be our JAX-RS service.

!!!!    In an Enterprise Java application, the Customer class would usually be a Java Persistence
        API (JPA) Entity bean and would be used to interact with a relational database. It could
        also be annotated with JAXB annotations that allow you to map a Java class directly to XML.

        To keep our example simple, Customer will be just a plain Java object and stored in memory.


        CustomerResource: Our JAX-RS Service
            we need to implement our JAX-RS service so that remote clients can interact with our
            customer database. A JAX-RS service is a Java class that uses JAX-RS annotations to
            bind and map specific incoming HTTP requests to Java methods that can service these requests.

!!!!!       In vanilla JAX-RS, services can either be singletons or per-request objects. A singleton
            means that one and only one Java object services HTTP requests. Per-request means
            that a Java object is created to process each incoming request and is thrown away at the
            end of that request. Per-request also implies statelessness, as no service state is held
            between requests.

!!!         For our example, we will write a CustomerResource class to implement our JAX-RS
            service and assume it will be a singleton. In this example, we need CustomerResource
            to be a singleton because it is going to hold state. It is going to keep a map of Customer
            objects in memory that our remote clients can access. In a real system, CustomerResource
            would probably interact with a database to retrieve and store customers and
            wouldn’t need to hold state between requests. In this database scenario, we could make
            CustomerResource per-request and thus stateless.

!!!!        The @javax.ws.rs.Path annotation placed on the CustomerResource class designates the class
            as a JAX-RS service. Java classes that you want to be recognized as JAX-RS services must have this annotation

            We use a java.util.concurrent.ConcurrentHashMap for customerDB because CustomerResource is a singleton
            and will have concurrent requests accessing the map. Using a java.util.HashMap would trigger concurrent access
            exceptions in a multithreaded environment.

            The createCustomer() method returns a response code of 201, “Created,” along with a
            Location header pointing to the absolute URI of the customer we just created.

!!          To bind HTTP POST requests to the createCustomer() method, we annotate it with
            the @javax.ws.rs.POST annotation. The @Path annotation we put on the CustomerRe
            source class, combined with this @POST annotation, binds all POST requests going to
            the relative URI /customers to the Java method createCustomer().

!!!         The @javax.ws.rs.Consumes annotation applied to createCustomer() specifies which
            media type the method is expecting in the message body of the HTTP input request. If
            the client POSTs a media type other than XML, an error code is sent back to the client.

!!!!!       The createCustomer() method takes one java.io.InputStream parameter.
            In JAXRS, any non-JAX-RS-annotated parameter is considered to be a representation of the
            HTTP input request’s message body. In this case, we want access to the method body in
            its most basic form, an InputStream.

        Retrieving customers
            We annotate the getCustomer() method with the @javax.ws.rs.GET annotation to
            bind HTTP GET operations to this Java method.
            We also annotate getCustomer() with the @javax.ws.rs.Produces annotation. This
            annotation tells JAX-RS which HTTP Content-Type the GET response will be. In this
            case, it is application/xml.

            We will write the response manually to the client through a java.io.OutputStream. In
            JAX-RS, when you want to do streaming manually, you must implement and return an
            instance of the javax.ws.rs.core.StreamingOutput interface from your JAX-RS
            method. StreamingOutput is a callback interface with one callback method, write()

            When the JAX-RS provider is ready to send an HTTP response
            body back over the network to the client, it will call back to the write() method we
            implemented to output the XML representation of our Customer object.

!!!!!       In general, you will not use the StreamingOutput interface to output responses. In
            Chapter 6, you will see that JAX-RS has a bunch of nice content handlers that can
            automatically convert Java objects straight into the data format you are sending across
            the wire. I didn’t want to introduce too many new concepts in the first introductory
            chapter, so the example only does simple streaming.

        Updating a customer
            We annotate the updateCustomer() method with @javax.ws.rs.PUT to bind HTTP
            PUT requests to this method. Like our getCustomer() method, updateCustomer() is
            annotated with an additional @Path annotation so that we can match /customers/
            {id} URIs

            The updateCustomer() method takes two parameters. The first is an id parameter that
            represents the Customer object we are updating. Like getCustomer(), we use the @Path
            Param annotation to extract the ID from the incoming request URI. The second pa‐
            rameter is an InputStream that will allow us to read in the XML document that was sent
            with the PUT request

        Utility methods
            I’ll admit, this example was a bit contrived. In a real system, we would not manually
            output XML or write all this boilerplate code to read in an XML document and convert
            it to a business object, but I don’t want to distract you from learning JAX-RS basics by
            introducing another API. In Chapter 6, I will show how you can use JAXB to map your
            Customer object to XML and have JAX-RS automatically transform your HTTP message
            body to and from XML.

        JAX-RS and Java Interfaces
            In JAX-RS, you are also allowed to define a Java interface that
            contains all your JAX-RS annotation metadata instead of applying all your annotations
            to your implementation class.

!!!!        Interfaces are a great way to scope out how you want to model your services. With an
            interface, you can write something that defines what your RESTful API will look like
            along with what Java methods they will map to before you write a single line of business
            logic. Also, many developers like to use this approach so that their business logic isn’t
            “polluted” with so many annotations. They think the code is more readable if it has
            fewer annotations.

            Finally, sometimes you do have the case where the same business
            logic must be exposed not only RESTfully, but also through SOAP and JAX-WS.

!!          Interfaces are a great way to isolate all this metadata into one logical and readable construct.

            As you can see, no JAX-RS annotations are needed within the implementing class. All
            our metadata is confined to the CustomerResource interface.

!!!!        If you need to, you can override the metadata defined in your interfaces by reapplying
            annotations within your implementation class. For example, maybe we want to enforce
            a specific character set for POST XML.
                public class CustomerResourceService implements CustomerResource {
                     @POST
                     @Consumes("application/xml;charset=utf-8")
                     public Response createCustomer(InputStream is) {
                        ... the implementation ...
                     }

            In this example, we are overriding the metadata defined in an interface for one specific
            method. When overriding metadata for a method, you must respecify all the annotation
            metadata for that method even if you are changing only one small thing.

!!          Overall, I do not recommend that you do this sort of thing. The whole point of using
            an interface to apply your JAX-RS metadata is to isolate the information and define it in one place.
            If your annotations are scattered about between your implementation class
            and interface, your code becomes a lot harder to read and understand.

        Inheritance
            The JAX-RS specification also allows you to define class and interface hierarchies if you so desire
                (you can specify the methods and annotations used for handing GET POST PUT in an abstract class, while
                in the concrete class you could implement the utility methods in another way)

!!!!        The only caveat with this approach is that the concrete subclass must annotate itself
            with the @Path annotation to identify it as a service class to the JAX-RS provider

    Deploying Our Service
        It is easiest to deploy JAX-RS within a Java EE–certified application server (e.g., JBoss)
!!!!!   or standalone Servlet 3 container (e.g., Tomcat). Before we can do that, we need to write
        one simple class that extends javax.ws.rs.core.Application. This class tells our application
        server which JAX-RS components we want to register
            (Dan: this is probably the implementation of Application class from the 2.0 specification..right now it a
            bit looks different)
            public abstract class Application {
                 private static final Set<Object> emptySet = Collections.emptySet();
                 public abstract Set<Class<?>> getClasses();
                 public Set<Object> getSingletons() {
                    return emptySet;
                 }
            }

!!!!!   The getClasses() method returns a list of JAX-RS service classes (and providers, but
        I’ll get to that in Chapter 6). Any JAX-RS service class returned by this method will
        follow the per-request model mentioned earlier. When the JAX-RS vendor implementation
        determines that an HTTP request needs to be delivered to a method of one of
        these classes, an instance of it will be created for the duration of the request and thrown
        away. You are delegating the creation of these objects to the JAX-RS runtime.

!!!!!   The getSingletons() method returns a list of JAX-RS service objects (and providers,
        too—again, see Chapter 6). You, as the application programmer, are responsible for
        creating and initializing these objects.

!!      The @ApplicationPath defines the relative base URL path for all our JAX-RS services
        in the deployment. So, in this example, all of our JAX-RS RESTful services will be pre‐
        fixed with the /services path when we execute on them.

        In Java EE and standalone servlet deployments, JAX-RS classes must be deployed within
        the application server’s servlet container as a Web ARchive (WAR). Think of a servlet
        container as your application server’s web server. A WAR is a JAR file that, in addition
        to Java class files, also contains other Java libraries along with dynamic (like JSPs) and
        static content (like HTML files or images) that you want to publish on your website.

        We are almost finished. All we have left to do is to create a WEB-INF/web.xml file within
        our archive.    (again this is for the 2.0 specification...for 3.0 it works without this file)
            <?xml version="1.0" encoding="UTF-8"?>
            <web-app xmlns="http://java.sun.com/xml/ns/javaee"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
             http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
             version="3.0">
            </web-app>
        Because this example deploys within a Java EE application server or standalone Servlet
        3.x container, all we need is an empty web.xml file. The server will detect that an Application
        class is within your WAR and automatically deploy it. Your application is now ready to use!

 https://jakarta.ee/specifications/restful-ws/3.0/jakarta-restful-ws-spec-3.0.html
        When an Application subclass is present in the archive, if both Application.getClasses and
        Application.getSingletons return an empty collection then all root resource classes and providers packaged in
        the web application MUST be included and the JAX-RS implementation is REQUIRED to discover them automatically
        by scanning a .war file as described above.
        If either getClasses or getSingletons returns a non-empty collection then only those classes or singletons
        returned MUST be included in the published JAX-RS application.

    Writing a Client
        The Client interface is responsible for managing client
        HTTP connections. I discuss the Client API in more detail in Chapter 8


===============================================================================================================
CHAPTER 4 - HTTP Method and URI Matching

    Binding HTTP Methods
        The @GET annotation instructs the JAX-RS runtime that this Java method will process HTTP GET requests
        to the URI /customers. You would use one of the other five annotations described earlier to
        bind to different HTTP operations. One thing to note, though, is that you may only
        apply one HTTP method annotation per Java method. A deployment error occurs if
        you apply more than one.

        Let’s take a look at @GET
        @GET, by itself, does not mean anything special to the JAX-RS provider. In other words,
        JAX-RS is not hardcoded to look for this annotation when deciding whether or not to
        dispatch an HTTP GET request. What makes the @GET annotation meaningful to a JAXRS provider
        is the meta-annotation @javax.ws.rs.HttpMethod. Meta-annotations are
        simply annotations that annotate other annotations. When the JAX-RS provider ex‐
        amines a Java method, it looks for any method annotations that use the meta-annotation
        @HttpMethod. The value of this meta-annotation is the actual HTTP operation that you
        want your Java method to bind to.

        What are the implications of this? This means that you can create new annotations that
        bind to HTTP methods other than GET, POST, DELETE, HEAD, and PUT. While
        HTTP is a ubiquitous, stable protocol, it is still constantly evolving. For example, con‐
        sider the WebDAV standard.1
        The WebDAV protocol makes the Web an interactive
        readable and writable medium. It allows users to create, change, and move documents
        on web servers. It does this by adding a bunch of new methods to HTTP like MOVE,
        COPY, MKCOL, LOCK, and UNLOCK.

        Although JAX-RS does not define any WebDAV-specific annotations, we could create
        them ourselves using the @HttpMethod annotation
            (Dan: this is of no interest to me right now..but nice to know)

    @Path
!!!     There’s more to the @javax.ws.rs.Path annotation than what we saw in our simple
        example in Chapter 3. @Path can have complex matching expressions so that you can
        be more specific about what requests get bound to which incoming URIs. @Path can
        also be used on a Java method as sort of an object factory for subresources of your
        application. We’ll examine both in this section

!!!     The @javax.ws.rs.Path annotation in JAX-RS is used to define a URI matching pattern
        for incoming HTTP requests. It can be placed upon a class or on one or more Java
        methods. For a Java class to be eligible to receive any HTTP requests, the class must be
        annotated with at least the @Path("/") expression. These types of classes are called JAXRS root resources.

!!      The value of the @Path annotation is an expression that denotes a relative URI to the
        context root of your JAX-RS application. For example, if you are deploying into a WAR
        archive of a servlet container, that WAR will have a base URI that browsers and remote
        clients use to access it. @Path expressions are relative to this URI.

!!      To receive a request, a Java method must have at least an HTTP method annotation like
        @javax.ws.rs.GET applied to it. This method is not required to have an @Path anno‐
        tation on it, though

!!!     You can also apply @Path to your Java method. If you do this, the URI matching pattern
        is a concatenation of the class’s @Path expression and that of the method’s. For example:
            @Path("/orders")
            public class OrderResource {
             @GET
             @Path("unpaid")
             public String getUnpaidOrders() {
             ...
             }
            }
        So, the URI pattern for getUnpaidOrders() would be the relative URI /orders/unpaid

        @Path Expressions
            The value of the @Path annotation is usually a simple string, but you can also define
            more complex expressions to satisfy your URI matching needs.

                @Path("customers/{firstname}-{lastname}")
                public String getCustomer(@PathParam("firstname") String first,
                                          @PathParam("lastname") String last)

            the URI is constructed with a customer’s first name, followed by a hyphen, ending with
            the customer’s last name

        Regular expressions
!!!         @Path expressions are not limited to simple wildcard matching expressions. For exam‐
            ple, our getCustomer() method takes an integer parameter. We can change our @Path
            value to match only digits:

                 @GET
                 @Path("{id : \\d+}")
                 public String getCustomer(@PathParam("id") int id)


            Other examples:

                 @GET
                 @Path("{id : .+}")
                 public String getCustomer(@PathParam("id") String id) {
                 ...
                 }

                 @GET
                 @Path("{id : .+}/address")
                 public String getAddress(@PathParam("id") String id) {

 !!         We’ve changed getCustomer()’s @Path expression to {id : .+}. The .+ is a regular
            expression that will match any stream of characters after /customers. So, the
            GET /customers/bill/burke request would be routed to getCustomer().
            The getAddress() method has a more specific expression. It will map any stream of
            characters after /customers that ends with /address. So, the GET /customers/bill/
            burke/address request would be routed to the getAddress() method

!!!!!   Precedence rules
            You may have noticed that, together, the @Path expressions for getCustomer() and
            getAddress() are ambiguous. A GET /customers/bill/burke/address request could
            match either getCustomer() or getAddress(), depending on which expression was
            matched first by the JAX-RS provider. The JAX-RS specification has defined strict sort‐
            ing and precedence rules for matching URI expressions and is based on a most specific
            match wins algorithm. The JAX-RS provider gathers up the set of deployed URI ex‐
            pressions and sorts them based on the following logic:
                1. The primary key of the sort is the number of literal characters in the full URI
                matching pattern. The sort is in descending order. In our ambiguous example,
                getCustomer()’s pattern has 11 literal characters: /customers/. The getAd
                dress() method’s pattern has 18 literal characters: /customers/ plus address.
                Therefore, the JAX-RS provider will try to match getAddress()’s pattern before
                getCustomer().
                2. The secondary key of the sort is the number of template expressions embedded
                within the pattern—that is, {id} or {id : .+}. This sort is in descending order.
                3. The tertiary key of the sort is the number of nondefault template expressions. A
                default template expression is one that does not define a regular expression—that
                is, {id}.

!!!!!       Let’s look at a list of sorted URI matching expressions and explain why one would match
            over another:
                1 /customers/{id}/{name}/address
                2 /customers/{id : .+}/address
                3 /customers/{id}/address
                4 /customers/{id : .+}
            Expressions 1–3 come first because they all have more literal characters than expression
            4. Although expressions 1–3 all have the same number of literal characters, expression
            1 comes first because sorting rule #2 is triggered. It has more template expressions than
            either pattern 2 or 3. Expressions 2 and 3 have the same number of literal characters
            and same number of template expressions. Expression 2 is sorted ahead of 3 because it
            triggers sorting rule #3; it has a template pattern that is a regular expression.
!!!!!       These sorting rules are not perfect. It is still possible to have ambiguities, but the rules
            cover 90% of use cases. If your application has URI matching ambiguities, your appli‐
            cation design is probably too complicated and you need to revisit and refactor your URI scheme.

 !!!    Encoding
            This is the set of allowable and reserved characters:
                • The US-ASCII alphabetic characters a–z and A–Z are allowable.
                • The decimal digit characters 0–9 are allowable.
                • All these other characters are allowable: _-!.~'()*.
                • These characters are allowed but are reserved for URI syntax: ,;:$&+=?/\[]@.

            All other characters must be encoded using the “%” character followed by a two-digit
            hexadecimal number. This hexadecimal number corresponds to the equivalent hexa‐
            decimal character in the ASCII table. So, the string bill&burke would be encoded as
            bill%26burke

!!!         When creating @Path expressions, you may encode its string, but you do not have to. If
            a character in your @Path pattern is an illegal character, the JAX-RS provider will au‐
            tomatically encode the pattern before trying to match and dispatch incoming HTTP requests
                @Path("roy&fielding")
           The @Path expression for getOurBestCustomer() would match incoming requests like
           GET /customers/roy%26fielding.

!!!!    Matrix Parameters
            One part of the URI specification that we have not touched on yet is matrix parame‐
            ters. Matrix parameters are name-value pairs embedded within the path of a URI string.
            For example:
                http://example.cars.com/mercedes/e55;color=black/2006

            They come after a URI segment and are delimited by the “;” character. The matrix
            parameter in this example comes after the URI segment e55. Its name is color and its
            value is black. Matrix parameters are different than query parameters, as they represent
            attributes of certain segments of the URI and are used for identification purposes. Think
            of them as adjectives. Query parameters, on the other hand, always come at the end of
            the URI and always pertain to the full resource you are referencing.

            Matrix parameters are ignored when matching incoming requests to JAX-RS resource
            methods. It is actually illegal to specify matrix parameters within an @Path expression.
            For example:
                @Path("/mercedes")
                public class MercedesService {
                     @GET
                     @Path("/e55/{year}")
                     @Produces("image/jpeg")
                     public Jpeg getE55Picture(@PathParam("year") String year)
                     ...
                 }

            If we queried our JAX-RS service with GET /mercedes/e55;color=black/2006, the
            getE55Picture() method would match the incoming request and would be invoked.
            Matrix parameters are not considered part of the matching process because they are
            usually variable attributes of the request. We’ll see in Chapter 5 how to access matrix
            parameter information within our JAX-RS resource methods.

!!!!Subresource Locators
        So far, I’ve shown you the JAX-RS capability to statically bind URI patterns expressed
        through the @Path annotation to a specific Java method. JAX-RS also allows you to
        dynamically dispatch requests yourself through subresource locators. Subresource lo‐
        cators are Java methods annotated with @Path, but with no HTTP method annotation,
        like @GET, applied to them. This type of method returns an object that is, itself, a JAXRS
        annotated service that knows how to dispatch the remainder of the request. This is
        best described using an example.

        see code examples from chpt 4 for this

        The CustomerDatabaseResource class is our root resource. It does not service any
        HTTP requests directly. It processes the database identifier part of the URI and locates
        the identified customer database.

!!!     Besides the added constructor, another difference in the CustomerResource class from
        previous examples is that it is no longer annotated with @Path. It is no longer a root
        resource in our system; it is a subresource and must not be registered with the JAX-RS
        runtime within an Application class.

 !!!    If the @Path expressions are the same between two different JAX-RS classes, then they
        both are used for request matching

    Wrapping Up
    In this chapter, we examined the intricacies of the @javax.ws.rs.Path annotation.
    @Path allows you to define complex URI matching patterns that can map to a Java
    method. These patterns can be defined using regular expressions and also support en‐
    coding. We also discussed subresource locators, which allow you to programmatically
    perform your own dynamic dispatching of HTTP requests


===============================================================================================================
CHAPTER 5 - JAX-RS Injection

!!  A lot of JAX-RS is pulling information from an HTTP request and injecting it into a
    Java method. You may be interested in a fragment of the incoming URI. You might be
    interested in a URI query string value. The client might be sending critical HTTP head‐
    ers or cookie values that your service needs to process the request. JAX-RS lets you grab
    this information à la carte, as you need it, through a set of injection annotations and APIs.

    The Basics
!!!!    There are a lot of different things JAX-RS annotations can inject. Here is a list of those
        provided by the specification:
            @javax.ws.rs.PathParam
            This annotation allows you to extract values from URI template parameters.
            @javax.ws.rs.MatrixParam
            This annotation allows you to extract values from URI matrix parameters.
            @javax.ws.rs.QueryParam
            This annotation allows you to extract values from URI query parameters.
            @javax.ws.rs.FormParam
            This annotation allows you to extract values from posted form data.
            @javax.ws.rs.HeaderParam
            This annotation allows you to extract values from HTTP request headers.
            @javax.ws.rs.CookieParam
            This annotation allows you to extract values from HTTP cookies set by the client.
            @javax.ws.rs.core.Context
            This class is the all-purpose injection annotation. It allows you to inject various
            helper and informational objects that are provided by the JAX-RS API.

        When the JAX-RS provider receives an HTTP request, it finds a Java method that will
        service this request. If the Java method has parameters that are annotated with any of
        these injection annotations, it will extract information from the HTTP request and pass
        it as a parameter when it invokes the method.

!!      For per-request resources, you may alternatively use these injection annotations on the
        fields, setter methods, and even constructor parameters of your JAX-RS resource class.
        Do not try to use these annotations on fields or setter methods if your component model
        does not follow per-request instantiation. Singletons process HTTP requests concur‐
        rently, so it is not possible to use these annotations on fields or setter methods, as con‐
        current requests will overrun and conflict with each other.

!!! @PathParam
        We looked at @javax.ws.rs.PathParam a little bit in Chapters 3 and 4. @PathParam
        allows you to inject the value of named URI path parameters that were defined in @Path expressions

        You can reference more than one URI path parameter in your Java methods. For in‐
        stance, let’s say we are using first and last name to identify a customer in our CustomerResource
            @Path("{first}-{last}")
            @GET
            @Produces("application/xml")
            public StreamingOutput getCustomer(@PathParam("first") String firstName,
                                               @PathParam("last") String lastName) {
                ...
            }

!!!     Sometimes a named URI path parameter will be repeated by different @Path expressions
        that compose the full URI matching pattern of a resource method. The path parameter
        could be repeated by the class’s @Path expression or by a subresource locator. In these
        cases, the @PathParam annotation will always reference the final path parameter. For example:
            @Path("/customers/{id}")
            public class CustomerResource {
                 @Path("/address/{id}")
                 @Produces("text/plain")
                 @GET
                 public String getAddress(@PathParam("id") String addressId) {...}
            }
        If our HTTP request was GET /customers/123/address/456, the addressId parameter
        in the getAddress() method would have the 456 value injected.

        Programmatic URI Information
            All this à la carte injection of path parameter data with the @PathParam annotation is
            perfect most of the time. Sometimes, though, you need a more general raw API to query
            and browse information about the incoming request’s URI. The interface
            javax.ws.rs.core.UriInfo provides such an API

            The getPath() methods allow you to obtain the relative path JAX-RS used to match
            the incoming request. You can receive the path string decoded or encoded. The get
            PathSegments() methods break up the entire relative path into a series of PathSeg
            ment objects. Like getPath(), you can receive this information encoded or decoded.
            Finally, getPathParameters() returns a map of all the path parameters defined for all
            matching @Path expressions.

            You can obtain an instance of the UriInfo interface by using the @jav
            ax.ws.rs.core.Context injection annotation
                (see chpt5 package for code examples)

!!! @MatrixParam
        Instead of injecting and processing PathSegment objects to obtain matrix parameter
        values, the JAX-RS specification allows you to inject matrix parameter values directly
        through the @javax.ws.rs.MatrixParam annotation.

        Using the @MatrixParam annotation shrinks our code and provides a bit more read‐
        ability. The only downside of @MatrixParam is that sometimes you might have a re‐
        peating matrix parameter that is applied to many different path segments in the URI.

            GET /mercedes/e55;color=black/2006/interior;color=tan

        Here, the color attribute shows up twice: once with the model and once with the interior.
        Using @MatrixParam("color") in this case would be ambiguous and we would have to
        go back to processing PathSegments to obtain this matrix parameter.

!!! @QueryParam
        The @javax.ws.rs.QueryParam annotation allows you to inject individual URI query
        parameters into your Java parameters. For example, let’s say we wanted to query a cus‐
        tomer database and retrieve a subset of all customers in the database. Our URI might
        look like this:
            GET /customers?start=0&size=10

        The start query parameter represents the customer index we want to start with and
        the size query parameter represents how many customers we want returned.

            (see code examples from chpt5)

        You may have the need to iterate through all query parameters defined on the request
        URI. The javax.ws.rs.core.UriInfo interface has a getQueryParameters() method
        that gives you a map containing all query parameters.
        You can inject instances of UriInfo using the @javax.ws.rs.core.Context annotation and thus obtain them.

!!! @FormParam
        The @javax.ws.rs.FormParam annotation is used to access application/x-www-formurlencoded request bodies.
        In other words, it’s used to access individual entries posted by an HTML form document

        Form data is URL-encoded when it goes across the wire.
        When using @FormParam, JAX-RS will automatically decode the form entry’s value be‐
        fore injecting it.

        (see code examples from chpt5)

!!! @HeaderParam
        The @javax.ws.rs.HeaderParam annotation is used to inject HTTP request header
        values. For example, what if your application was interested in the web page that referred
        to or linked to your web service? You could access the HTTP Referer header using the
        @HeaderParam

             @GET
             @Produces("text/html")
             public String get(@HeaderParam("Referer") String referer) {
                ...
             }
        The @HeaderParam annotation is pulling the Referer header directly from the HTTP
        request and injecting it into the referer method parameter.

        Sometimes you need programmatic access to view all headers within the incoming
        request. For instance, you may want to log them. The JAX-RS specification provides the
        javax.ws.rs.core.HttpHeaders interface for such scenarios

!!! @CookieParam
        Servers can store state information in cookies on the client, and can retrieve that in‐
        formation when the client makes its next request. Many web applications use cookies
        to set up a session between the client and the server. They also use cookies to remember
        identity and user preferences between requests. These cookie values are transmitted
        back and forth between the client and server via cookie headers.

        The @javax.ws.rs.CookieParam annotation allows you to inject cookies sent by a client
        request into your JAX-RS resource methods.

            (see code examples from chpt5)

        The use of @CookieParam here makes the JAX-RS provider search all cookie headers for
        the customerId cookie value. It then converts it into an int and injects it into the custId
        parameter.

        If you need more information about the cookie other than its base value, you can instead
        inject a javax.ws.rs.core.Cookie object

        The getName() and getValue() methods correspond to the string name and value of
        the cookie you are injecting. The getVersion() method defines the format of the cookie
        header—specifically, which version of the cookie specification the header follows. The
        getDomain() method specifies the DNS name that the cookie matched. The get
        Path() method corresponds to the URI path that was used to match the cookie to the
        incoming request. All these attributes are defined in detail by the IETF cookie
        specification.

        You can also obtain a map of all cookies sent by the client by injecting a reference to
        javax.ws.rs.core.HttpHeaders

!!! @BeanParam
        The @BeanParam annotation is something new added in the JAX-RS 2.0 specification. It
        allows you to inject an application-specific class whose property methods or fields are
        annotated with any of the injection parameters discussed in this chapter. For example,
        take this class:
            public class CustomerInput {
             @FormParam("first")
             String firstName;
             @FormParam("list")
             String lastName;
             @HeaderParam("Content-Type")
             String contentType;
             public String getFirstName() {...}
                ....
            }

        Here we have a simple POJO (Plain Old Java Object) that contains the first and last
        names of a created customer, as well as the content type of that customer. We can have
        JAX-RS create, initialize, and inject this class using the @BeanParam annotation:
            @Path("/customers")
            public class CustomerResource {
             @POST
             public void createCustomer(@BeanParam CustomerInput newCust) {
             ...
             }
            }
        The JAX-RS runtime will introspect the @BeanParam parameter’s type for injection an‐
        notations and then set them as appropriate. In this example, the CustomerInput class
!!!!    is interested in two form parameters and a header value. This is a great way to aggregate
        information instead of having a long list of method parameters.

    Common Functionality
        Each of these injection annotations has a common set of functionality and attributes.
        Some can automatically be converted from their string representation within an HTTP
        request into a specific Java type. You can also define default values for an injection
        parameter when an item does not exist in the request. Finally, you can work with en‐
        coded strings directly, rather than having JAX-RS automatically decode values for you.

        Automatic Java Type Conversion
            JAXRS can convert this string data into any Java type that you want, provided that it matches
            one of the following criteria:
                1. It is a primitive type. The int, short, float, double, byte, char, and boolean types
                all fit into this category.
                2. It is a Java class that has a constructor with a single String parameter.
                3. It is a Java class that has a static method named valueOf() that takes a single String
                argument and returns an instance of the class.
                4. It is a java.util.List<T>, java.util.Set<T>, or java.util.SortedSet<T>,
                where T is a type that satisfies criteria 2 or 3 or is a String. Examples are List<Dou
                ble>, Set<String>, or SortedSet<Integer>.


            see examples from chpt5 with Color for example, where we use ColorEnum, which works as long as the enum is
            defined in the same class as the resource from what it seems..

        ParamConverters
            Sometimes a parameter class cannot use the default mechanisms to convert from string
            values. Either the class has no String constructor or no valueOf() method, or the ones
            that exist won’t work with your HTTP requests. For this scenario, JAX-RS 2.0 has pro‐
            vided an additional component to help with parameter conversions.
                package javax.ws.rs.ext;
                public interface ParamConverter<T> {
                 public T fromString(String value);
                 public String toString(T value);
                }

            (so there is this way for which I did not add code, of using developer defined parameter converters)


        Collections
            GET /customers?orderBy=last&orderBy=first           notice that there are 2 orderBy query params

            In this request, the orderBy query parameter is repeated twice with different values. We
            can let our JAX-RS provider represent these two parameters as a java.util.List and
            inject this list with one @QueryParam annotation:

                 @QueryParam("orderBy") List<String> orderBy)

!!      @DefaultValue
            In many types of JAX-RS services, you may have parameters that are optional. When a
            client does not provide this optional information within the request, JAX-RS will, by
            default, inject a null value for object types and a zero value for primitive types.
            Many times, though, a null or zero value may not work as a default value for your
            injection. To solve this problem, you can define your own default value for optional
            parameters by using the @javax.ws.rs.DefaultValue annotation.

        @Encoded
            URI template, matrix, query, and form parameters must all be encoded by the HTTP
            specification. By default, JAX-RS decodes these values before converting them into the
            desired Java types. Sometimes, though, you may want to work with the raw encoded
            values. Using the @javax.ws.rs.Encoded annotation gives you the desired effect

    Wrapping Up
        In this chapter, we examined how to use JAX-RS injection annotations to insert bits and
        pieces of an HTTP request à la carte into your JAX-RS resource method parameters.
        While data is represented as strings within an HTTP request, JAX-RS can automatically
        convert this data into the Java type you desire, provided that the type follows certain
        constraints. These features allow you to write compact, easily understandable code and
        avoid a lot of the boilerplate code you might need if you were using other frameworks
        like the servlet specification


===============================================================================================================
CHAPTER 6 - JAX-RS Content Handlers

    In this chapter, we will focus on the message body of an HTTP request and
    response. In the examples in previous chapters, we used low-level streaming to read in
    requests and write out responses. To make things easier, JAX-RS also allows you to
    marshal message bodies to and from specific Java types. It has a number of built-in
    providers, but you can also write and plug in your own providers. Let’s look at them all.

    Built-in Content Marshalling
        JAX-RS has a bunch of built-in handlers that can marshal to and from a few different
        specific Java types. While most are low-level conversions, they can still be useful to your
        JAX-RS classes

    javax.ws.rs.core.StreamingOutput
        We were first introduced to StreamingOutput back in Chapter 3. StreamingOutput is
        a simple callback interface that you implement when you want to do raw streaming of
        response bodies
             @GET
             @Produces("text/plain")
             StreamingOutput get() {
                 return new StreamingOutput() {
                    public void write(OutputStream output) throws IOException, WebApplicationException {
                        output.write("hello world".getBytes());
                    }
                };
             }

 !!!    Here, we’re getting access to the raw java.io.OutputStream through the write()
        method and outputting a simple string to the stream. I like to use an anonymous inner
        class implementation of the StreamingOutput interface rather than creating a separate
        public class. Since the StreamingOutput interface is so tiny, I think it’s beneficial to keep
        the output logic embedded within the original JAX-RS resource method so that the code
        is easier to follow. Usually, you’re not going to reus

        You may be asking yourself, “Why not just inject an OutputStream directly? Why have
        a callback object to do streaming output?” That’s a good question! The reason for having
        a callback object is that it gives the JAX-RS implementation freedom to handle output
        however it wants. For performance reasons, it may sometimes be beneficial for the JAXRS implementation
        to use a different thread other than the calling thread to output
        responses. More importantly, many JAX-RS implementations have an interceptor model
        that abstracts things out like automatic GZIP encoding or response caching. Streaming
        directly can usually bypass these architectural constructs. Finally, the Servlet 3.0 spec‐
        ification has introduced the idea of asynchronous responses. The callback model fits in
        very nicely with the idea of asynchronous HTTP within the Servlet 3.0 specification.

    java.io.InputStream, java.io.Reader
        For reading request message bodies, you can use a raw InputStream or Reader for
        inputting any media type.

        (see code examples in chpt6)

        You are not limited to using InputStream and Reader for reading input request message
        bodies. You can also return these as response objects.

        The JAX-RS implementation will read from this input stream into
        a buffer and write it back out incrementally to the response output stream. We must
        specify the @Produces annotation so that the JAX-RS implementation knows how to set
        the Content-Type header.

    java.io.File
        Instances of java.io.File can also be used for input and output of any media type.

        We create a java.io.File based on this path and return it as
        our response body. The JAX-RS implementation will open up an InputStream based
        on this file reference and stream into a buffer that is written back incrementally to the
        response’s output stream. We must specify the @Produces annotation so that the JAXRS implementation
        knows how to set the Content-Type header.

        You can also inject java.io.File instances that represent the incoming request re‐
        sponse body.
        The way this works is that the JAX-RS implementation creates a temporary file for input
        on disk.

    byte[]
        A raw array of bytes can be used for the input and output of any media type.
        For JAX-RS resource methods that return an array of bytes, you must specify the @Pro
        duces annotation so that JAX-RS knows what media to use to set the Content-Type
        header.

    String, char[]
        Most of the data formats on the Internet are text based. JAX-RS can convert any textbased format to and
        from either a String or an array of characters.
        For JAX-RS resource methods that return a String or an array of characters, you must
        specify the @Produces annotation so that JAX-RS knows what media to use to set the
        Content-Type header.

        The JAX-RS specification does require that implementations be sensitive to the char‐
        acter set specified by the Content-Type when creating an injected String. (so if you specify the
        content-type and char encoding in the request headers, the implementation of JAX-RS will make sure
        to have the String content respect that)

    MultivaluedMap<String, String> and Form Input
        HTML forms are a common way to post data to web servers. Form data is encoded as
        the application/x-www-form-urlencoded media type. In Chapter 5, we saw how you
        can use the @FormParam annotation to inject individual form parameters from the re‐
        quest. You can also inject a MultivaluedMap<String, String> that represents all the
        form data sent with the request

        You may also return a MultivaluedMap of form data as your response. We do this in our example.

    javax.xml.transform.Source
        The javax.xml.transform.Source interface represents XML input or output.It is usu‐
        ally used to perform XSLT transformations on input documents


    JAXB
        JAXB is an older Java specification and is not defined by JAX-RS. JAXB is an annotation
        framework that maps Java classes to XML and XML schema. It is extremely useful be‐
        cause instead of interacting with an abstract representation of an XML document, you
        can work with real Java objects that are closer to the domain you are modeling. JAX-RS
        has built-in support for JAXB, but before we review these handlers, let’s get a brief
        overview of the JAXB framework.

    Intro to JAXB
        A whole book could be devoted to explaining the intricacies of JAXB, but I’m only going
        to focus here on the very basics of the framework. If you want to map an existing Java
        class to XML using JAXB, there are a few simple annotations you can use.

        The @javax.xml.bind.annotation.XmlRootElement annotation is put on Java classes
        to denote that they are XML elements. The name() attribute of @XmlRootElement speci‐
        fies the string to use for the name of the XML element.

        The @javax.xml.bind.annotation.XmlAttribute annotation was placed on the id
        field of our Customer class. This annotation tells JAXB to map the field to an id attribute
        on the main <Customer> element of the XML document. The @XmlAttribute annota‐
        tion also has a name() attribute that allows you to specify the exact name of the XML
        attribute within the XML document. By default, it is the same name as the annotated
        field.

        In our example, the @javax.xml.bind.annotation.XmlElement annotationwas placed
        on the fullname field of our Customer class. This annotation tells JAXB to map the field
        to a <fullname> element within the main <Customer> element of the XML document.

!!      There are a number of other annotations and settings that allow you to do some more
        complex Java-to-XML mappings. JAXB implementations are also required to have
        command-line tools that can automatically generate JAXB-annotated Java classes from
        XML schema documents. If you need to integrate with an existing XML schema, these
        autogeneration tools are the way to go.

!!!!    To marshal Java classes to and from XML, you need to interact with the
        javax.xml.bind.JAXBContext class. JAXBContext instances introspect your classes to
        understand the structure of your annotated classes. They are used as factories for the
        javax.xml.bind.Marshaller and javax.xml.bind.Unmarshaller interfaces. Marshal
        ler instances are used to take Java objects and output them as XML. Unmarshaller
        instances are used to take XML input and create Java objects out of it.

    JAXB JAX-RS Handlers
        The JAX-RS specification requires implementations to automatically support the mar‐
        shalling and unmarshalling of classes that are annotated with @XmlRootElement or
        @XmlType as well as objects wrapped inside javax.xml.bind.JAXBElement instances.

!!!     As you can see, once you’ve applied JAXB annotations to your Java classes, it is very
        easy to exchange XML documents between your client and web services. The built-in
        JAXB handlers will handle any JAXB-annotated class for the application/xml, text/
        xml, or application/*+xml media types. By default, they will also manage the creation
        and initialization of JAXBContext instances. Because the creation of JAXBContext in‐
        stances can be expensive, JAX-RS implementations usually cache them after they are
        first initialized.

!!!!!  (If you want to use the JAXB on openliberty you need to enable the feature:
                 <feature>xmlBinding-3.0</feature>   )

    JAXB and JSON
        JSON is a text-based format that can be directly interpreted by JavaScript.

        JSON is a much simpler format than XML. Objects are enclosed in curly brackets, “{}”,
        and contain key/value pairs. Values can be quoted strings, Booleans (true or false),
        numeric values, or arrays of these simple types. Here’s an example:
            {
             "id" : 42,
             "name" : "Bill Burke",
             "married" : true,
             "kids" : [ "Molly", "Abby" ]
            }

        http://www.sklar.com/badgerfish/   is mentioned
        BadgerFish is a convention for translating an XML document into a JSON object. Once you've got your XML
        document represented as a JSON object, it's easy to manipulate from within Javascript.

        It doesn’t make much sense to use XML schema to define JSON data structures. The
        main reason is that JSON is a richer data format that supports things like maps, lists,
        and numeric, Boolean, and string data. It is a bit quirky modeling these sorts of simple
        data structures with XML schema. To solve this problem, the JSON community has
        come up with JSON schema. Here’s an example of what it looks like when you define a
        JSON data structure representing our customer example:
            {
            "description":"A customer",
            "type":"object",
            "properties":
                {"first": {"type": "string"},
                "last" : {"type" : "string"}
             }
            }

        If you do a Google search on Java and JSON, you’ll find a plethora of frameworks that
        help you marshal and unmarshal between Java and JSON. One particularly good one is
        the Jackson2
         framework. It has a prewritten JAX-RS content handler that can automat‐
        ically convert Java beans to and from JSON. It can also generate JSON schema docu‐
        ments from a Java object model.
        The way it works by default is that it introspects your Java class, looking for properties,
        and maps them into JSON

        http://www.mastertheboss.com/java-ee/json/comparing-jackson-vs-jsonb/
        (in openliberty jsonb is used....jackson is mentioned in the book)

!!!     The Jackson framework’s JAX-RS integration actually does all this work for you, so all
        you have to do in your JAX-RS classes is specify the output and input format as appli
        cation/json when writing your JAX-RS methods.

    Custom Marshalling
        So far in this chapter, we’ve focused on built-in JAX-RS handlers that can marshal and
        unmarshal message content. Unfortunately, there are hundreds of data formats available
        on the Internet, and the built-in JAX-RS handlers are either too low level to be useful
        or may not match the format you need. Luckily, JAX-RS allows you to write your own
        handlers and plug them into the JAX-RS runtime.
        To illustrate how to write your own handlers, we’re going to pretend that there is no
        built-in JAX-RS JAXB support and instead write one ourselves using JAX-RS APIs.

    MessageBodyWriter
        The first thing we’re going to implement is JAXB-marshalling support. To automatically
        convert Java objects into XML, we have to create a class that implements the
        javax.ws.rs.ext.MessageBodyWriter

        (Dan i went through this part fast...this is something detailed that I won't remember anyway, and
        it is good to know when you actually want to do a custom marshalling of such nature.)

    MessageBodyReader
        Now that we have written a MessageBodyWriter to convert a Java object into XML and
        output it as the HTTP response body, let’s write an unmarshaller that knows how to
        convert HTTP XML request bodies back into a Java object. To do this, we need to use
        the javax.ws.rs.ext.MessageBodyReader interface

        (Dan i went through this part fast...this is something detailed that I won't remember anyway, and
        it is good to know when you actually want to do a custom marshalling of such nature.)

    Wrapping Up
        In this chapter, you learned that JAX-RS can automatically convert Java objects to a
        specific data type format and write it out as an HTTP response. It can also automatically
        read in HTTP request bodies and create specific Java objects that represent the request.
        JAX-RS has a number of built-in handlers, but you can also write your own custom
        marshallers and unmarshallers

===============================================================================================================
CHAPTER 7 - Server Responses and Exception Handling

    We haven’t talked a lot about the default behavior of JAX-RS re‐
    source methods, particularly around HTTP response codes in success and failure sce‐
    narios. Also, in the real world, you can’t always have things so neat and clean. Many
    times you need to send specific response headers to deal with complex error conditions.
    This chapter first discusses the default response codes that vanilla JAX-RS resource
    methods give. It then walks you through writing complex responses using JAX-RS APIs.
    Finally, it goes over how exceptions can be handled within JAX-RS.

    Default Response Codes
        The default response codes that JAX-RS uses are pretty straightforward. There is pretty
        much a one-to-one relationship to the behavior described in the HTTP 1.1 Method
        Definition specification.

        Let’s examine what the response codes would be for both
        success and error conditions for the following JAX-RS resource class:

             @Path("{id}")
             @GET
             @Produces("application/xml")
             public Customer getCustomer(@PathParam("id") int id) {...}

             @POST
             @Produces("application/xml")
             @Consumes("application/xml")
             public Customer create(Customer newCust) {...}

             @PUT
             @Path("{id}")
             @Consumes("application/xml")
             public void update(@PathParam("id") int id, Customer cust) {...}

             @Path("{id}")
             @DELETE
             public void delete(@PathParam("id") int id) {...}

!!!!    Successful Responses
            Successful HTTP response code numbers range from 200 to 399. For the create() and
            getCustomer() methods of our CustomerResource class, they will return a response
            code of 200, “OK,” if the Customer object they are returning is not null. If the return
            value is null, a successful response code of 204, “No Content,” is returned. The 204
            response is not an error condition. It just tells the client that everything went OK, but
            that there is no message body to look for in the response. If the JAX-RS resource method’s
            return type is void, a response code of 204, “No Content,” is returned. This is the case
            with our update() and delete() methods.
            The HTTP specification is pretty consistent for the PUT, POST, GET, and DELETE
            methods. If a successful HTTP response contains a message body, 200, “OK,” is the
            response code. If the response doesn’t contain a message body, 204, “No Content,” must
            be returned.

 !!!    Error Responses
            Standard HTTP error response code numbers range from 400 to 599. In our example,
            if a client mistypes the request URI, for example, to customers, it will result in the server
            not finding a JAX-RS resource method that can service the request. In this case, a 404,
            “Not Found,” response code will be sent back to the client.

            For our getCustomer() and create() methods, if the client requests a text/html re‐
            sponse, the JAX-RS implementation will automatically return a 406, “Not Acceptable,”
            response code with no response body. This means that JAX-RS has a relative URI path
            that matches the request, but doesn’t have a JAX-RS resource method that can produce
            the client’s desired response media type.

  !!!       So, in our example, if our client does a PUT, GET, or DELETE on the /custom
            ers URI, it will get a 405 response because POST is the only supported method for that URI.
            The JAX-RS implementation will also return an Allow response header back to
            the client that contains a list of HTTP methods the URI supports. So, if our client did a
            GET /customers in our example, the server would send this response back:
                HTTP/1.1 405, Method Not Allowed
                Allow: POST

    Complex Responses
!!!     Sometimes the web service you are writing can’t be implemented using the default re‐
        quest/response behavior inherent in JAX-RS. For the cases in which you need to ex‐
        plicitly control the response sent back to the client, your JAX-RS resource methods can
        return instances of javax.ws.rs.core.Response

        The Response class is an abstract class that contains three simple methods. The getEn
        tity() method returns the Java object you want converted into an HTTP message body.
        The getStatus() method returns the HTTP response code. The getMetadata() meth‐
        od is a MultivaluedMap of response headers.

!!!     Response objects cannot be created directly; instead, they are created from jav
        ax.ws.rs.core.Response.ResponseBuilder instances returned by one of the static
        helper methods of Response

        If you want an explanation of each and every static helper method, the JAX-RS Javadocs
        are a great place to look.

        For example:
            public static ResponseBuilder ok(Object entity, MediaType type) {...}

!!!     The ok() method here takes the Java object you want converted into an HTTP response
        and the Content-Type of that response. It returns a preinitialized ResponseBuilder
        with a status code of 200, “OK.” The other helper methods work in a similar way, setting
        appropriate response codes and sometimes setting up response headers automatically

        The ResponseBuilder class is a factory that is used to create one individual Response
        instance. You store up state you want to use to create your response and when you’re
        finished, you have the builder instantiate the Response
            (Dan : the classic builder design pattern )

        As you can see, ResponseBuilder has a lot of helper methods for initializing various
        response headers. I don’t want to bore you with all the details, so check out the JAX-RS
        Javadocs for an explanation of each one. I’ll be giving examples using many of them
        throughout the rest of this book.

            (see chpt7 package examples)

!!      We initialize the response body using the Response.ok() method.
        The status code of the ResponseBuilder is automatically initialized with 200. Using the
        ResponseBuilder.language() method, we then set the Content-Language header to
        French. We then use the ResponseBuilder.header() method to set a custom response
        header. Finally, we create and return the Response object using the ResponseBuild
        er.build() method.

        Returning Cookies
            JAX-RS also provides a simple class to represent new cookie values. This class is
            javax.ws.rs.core.NewCookie

            To set response cookies, create instances of NewCookie and pass them to the method
            ResponseBuilder.cookie().

        The Status Enum
            For instance, instead of using a numeric constant to set a Response status
            code, you may want a static final variable to represent a specific code. The JAX-RS
            specification provides a Java enum called javax.ws.rs.core.Response.Status for this very purpose.

!!!!!       Each Status enum value is associated with a specific family of HTTP response codes.
            These families are identified by the Status.Family Java enum. Codes in the 100 range
            are considered informational. Codes in the 200 range are considered successful. Codes
            in the 300 range are success codes, but fall under the redirection category. Error codes
            are in the 400 to 500 ranges. The 400s are client errors and 500s are server errors.

        javax.ws.rs.core.GenericEntity

            The GenericEntity class is a Java generic template. What you do here is create an
            anonymous class that extends GenericEntity, initializing the GenericEntity’s tem‐
            plate with the generic type you’re using. If this looks a bit magical, it is. The creators of
            Java generics made things a bit difficult, so we’re stuck with this solution.

                @GET
                @Produces("application/xml")
                public Response getCustomerList() {
                     List<Customer> list = new ArrayList<Customer>();
                     list.add(new Customer(...));
                     GenericEntity entity = new GenericEntity<List<Customer>>(list){};
                     return Response.ok(entity).build();
                }

    Exception Handling
        Errors can be reported to a client either by creating and returning the appropriate
 !!!    Response object or by throwing an exception. Application code is allowed to throw any
        checked (classes extending java.lang.Exception) or unchecked (classes extending
        java.lang.RuntimeException) exceptions they want.

 !!!!   Thrown exceptions are handled by the JAX-RS runtime if you have registered an exception mapper.
        Exception mappers can convert an exception to an HTTP response. If the thrown exception is not handled
        by a mapper, it is propagated and handled by the container (i.e., servlet) JAX-RS is
        running within. JAX-RS also provides the javax.ws.rs.WebApplicationException.
        This can be thrown by application code and automatically processed by JAX-RS without
        having to write an explicit mapper. Let’s look at how to use the WebApplicationExcep
        tion first. We’ll then examine how to write your own specific exception mappers.

        javax.ws.rs.WebApplicationException
            JAX-RS has a built-in unchecked exception that applications can throw. This exception
            is preinitialized with either a Response or a particular status code

 !!!!       When JAX-RS sees that a WebApplicationException has been thrown by application
            code, it catches the exception and calls its getResponse() method to obtain a Response
            to send back to the client. If the application has initialized the WebApplicationException
            with a status code or Response object, that code or Response will be used to create
            the actual HTTP response. Otherwise, the WebApplicationException will return a
            status code of 500, “Internal Server Error,” to the client.

        Exception Mapping
 !!!        Many applications have to deal with a multitude of exceptions thrown from application
            code and third-party frameworks. Relying on the underlying servlet container to handle
            the exception doesn’t give us much flexibility. Catching and then wrapping all these
            exceptions within WebApplicationException would become quite tedious. Alterna‐
            tively, you can implement and register instances of javax.ws.rs.ext.ExceptionMapper.
            These objects know how to map a thrown application exception to a Response
            object:
                public interface ExceptionMapper<E extends Throwable> {
                {
                 Response toResponse(E exception);
                }

!!!         For example, one exception that is commonly thrown in Java Persistence API (JPA)–
            based database applications is javax.persistence.EntityNotFoundException. It is
            thrown when JPA cannot find a particular object in the database. Instead of writing code
            to handle this exception explicitly, you could write an ExceptionMapper to handle this
            exception for you
                (see code examples)

            Our ExceptionMapper implementation must be annotated with the @Provider anno‐
            tation. This tells the JAX-RS runtime that it is a component. The class implementing
            the ExceptionMapper interface must provide the parameterized type of the Exception
            Mapper. JAX-RS uses this generic type information to match up thrown exceptions to
            ExceptionMappers. Finally, the toResponse() method receives the thrown exception
            and creates a Response object that will be used to build the HTTP response.

!!!!!       JAX-RS supports exception inheritance as well. When an exception is thrown, JAX-RS
            will first try to find an ExceptionMapper for that exception’s type. If it cannot find one,
            it will look for a mapper that can handle the exception’s superclass. It will continue this
            process until there are no more superclasses to match against.

            Finally, ExceptionMappers are registered with the JAX-RS runtime using the deploy‐
            ment APIs discussed in Chapter 14.
                (Dan seems like i have to add the ExceptionMapper class to the ShoppingApplication class to the
                set of classes...
                Later Edit : Yes this is how they do it in the book as well)

        Exception Hierarchy
            JAX-RS 2.0 has added a nice exception hierarchy for various HTTP error conditions.
            So, instead of creating an instance of WebApplicationException and initializing it with
            a specific status code, you can use one of these exceptions instead

            example
                NotFoundException()

            Like the other exceptions in the exception hierarchy, NotFoundException inherits from
            WebApplicationException. If you looked at the code, you’d see that in its constructor
            it is initializing the status code to be 404

            Table 7-1 lists some other exceptions you can use for error conditions that are under
            the javax.ws.rs package
!!!!
                BadRequestException         400 Malformed message
                NotAuthorizedException      401 Authentication failure
                ForbiddenException          403 Not permitted to access
                NotFoundException           404 Couldn’t find resource
                NotAllowedException         405 HTTP method not supported
                NotAcceptableException      406 Client media type requested not supported
                NotSupportedException       415 Client posted media type not supported
                InternalServerErrorException 500 General server error
                ServiceUnavailableException  503 Server is temporarily unavailable or busy

            BadRequestException is used when the client sends something to the server that the
            server cannot interpret. The JAX-RS runtime will actually throw this exception in
            certain scenarios. The most obvious is when a PUT or POST request has submitted
            malformed XML or JSON that the MessageBodyReader fails to parse. JAX-RS will also
            throw this exception if it fails to convert a header or cookie value to the desired type

            ForbiddenException is generally used when the client making the invocation does not
            have permission to access the resource it is invoking on. In Java EE land, this is usually
            because the authenticated client does not have the specific role mapping required

            NotAllowedException is used when the HTTP method the client is trying to invoke
            isn’t supported by the resource the client is accessing. The JAX-RS runtime will auto‐
            matically throw this exception if there isn’t a JAX-RS method that matches the invoked
            HTTP method

            NotAcceptableException is used when the client is requesting a specific format through
            the Accept header. The JAX-RS runtime will automatically throw this exception if there
            is not a JAX-RS method with an @Produces annotation that is compatible with the client’s
            Accept header.

            NotSupportedException is used when a client is posting a representation that the server
            does not understand. The JAX-RS runtime will automatically throw this exception if
            there is no JAX-RS method with an @Consumes annotation that matches the ContentType of the posted entity.

            InternalServerErrorException is a general-purpose error that is thrown by the server.
            For applications, you would throw this exception if you’ve reached an error condition
            that doesn’t really fit with the other HTTP error codes. The JAX-RS runtime throws this
            exception if a MessageBodyWriter fails or if there is an exception thrown from an
            ExceptionMapper.

            ServiceUnavailableException is used when the server is temporarily unavailable or
            busy. In most cases, it is OK for the client to retry the request at a later time. The HTTP
            503 status code is often sent with a Retry-After header. This header is a suggestion to
            the client when it might be OK to retry the request. Its value is in seconds or a formatted
            date string.

    !!!!    Mapping default exceptions
            What’s interesting about the default error handling for JAX-RS is that you can write an
            ExceptionMapper for these scenarios. For example, if you want to send back a different
            response to the client when JAX-RS cannot find an @Produces match for an Accept
            header, you can write an ExceptionMapper for NotAcceptableException. This gives
            you complete control on how errors are handled by your application.

    Wrapping Up
        In this chapter, you learned that JAX-RS has default response codes for both success
        and error conditions. For more complex responses, your JAX-RS resource methods can
        return javax.ws.rs.core.Response objects. JAX-RS has a few exception utilities. You
        can throw instances of javax.ws.rs.WebApplicationException or let the underlying
        servlet container handle the exception. Or, you can write an ExceptionMapper that can
        map a particular exception to an HTTP response

===============================================================================================================
CHAPTER 8 - JAX-RS Client API

    One huge gaping hole in the first version of the JAX-RS specification was the lack of a
    client API. You could slog through the very difficult-to-use java.net.URL set of classes
    to invoke on remote RESTful services. Or you could use something like Apache HTTP
    Client, which is not JAX-RS aware, so you would have to do marshalling and unmar‐
    shalling of Java objects manually. Finally, you could opt to use one of the proprietary
    client APIs of one of the many JAX-RS implementations out there. This would, of course,
    lock you into that vendor’s implementation. JAX-RS 2.0 fixed this problem by intro‐
    ducing a new HTTP client API.

    Client Introduction
        Before I dive into the Client API, let’s look at a simple code example that illustrates the
        basics of the API:

            Client client = ClientBuilder.newClient();
            WebTarget target = client.target("http://commerce.com/customers");
            Response response = target.post(Entity.xml(new Customer("Bill", "Burke)));
            response.close();
            Customer customer = target.queryParam("name", "Bill Burke").request().get(Customer.class);
            client.close();

       Bootstrapping with ClientBuilder
 !!!!       The javax.ws.rs.client.Client interface is the main entry point into the JAX-RS
            Client API. Client instances manage client socket connections and are pretty heavy‐
            weight. Instances of this interface should be reused wherever possible, as it can be quite
            expensive to create and destroy these objects. Client objects are created with the
            ClientBuilder class

 !!!!       The easiest way to create a Client is to call ClientBuilder.newClient(). It instantiates
            a preinitialized Client that you can use right away. To fine-tune the construction of
            your Client interfaces, the newBuilder() method creates a ClientBuilder instance
            that allows you to register components and set configuration properties

            The ClientBuilder class also has methods to configure SSL. We’ll cover this in detail
            in Chapter 15. Let’s take a look at using ClientBuilder:
                Client client = ClientBuilder.newBuilder()
                     .property("connection.timeout", 100)
                     .sslContext(sslContext)
                     .register(JacksonJsonProvider.class)
                     .build();

            We create a ClientBuilder instance by calling the static method ClientBuilder.new
            Builder(). We then set a proprietary, JAX-RS implementation–specific configuration
            property that controls socket connection timeouts. Next we specify the sslContext we
            want to use to manage HTTPS connections. The RESTful services we’re going to interact
            with are primarily JSON, so we register() an @Provider that knows how to marshal
            Java objects to and from JSON. Finally, we call build() to create the Client instance.

!!!!!       Always remember to close() your Client objects. Client objects
            often pool connections for performance reasons. If you do not close
            them, you are leaking valuable system resources. While most JAX-RS
            implementations implement a finalize() method for Client, it is not
            a good idea to rely on the garbage collector to clean up poorly written code.

        Client and WebTarget
            Now that we have a Client, there’s a bunch of stuff we can do with this object. Like
            ClientBuilder, the Client interface implements Configurable. This allows you to
            change configuration and register components for the Client on the fly as your application executes.

 !!!        The most important purpose of Client, though, is to create WebTarget instances

            The WebTarget interface represents a specific URI you want to invoke on. Through the
            Client interface, you can create a WebTarget using one of the target() methods

            WebTarget has additional methods to extend the URI you originally constructed it with.
            You can add path segments or query parameters by invoking path() and queryParam().
            If the WebTarget represents a URI template, the resolveTemplate() methods can
            fill in those variables:
                WebTarget target = client.target("http://commerce.com/customers/{id}")
                     .resolveTemplate("id", "123")
                     .queryParam("verbose", true);

            In this example, we initialized a WebTarget with a URI template string. The resolve
            Template() method fills in the id expression, and we add another query parameter. If
            you take a look at the UriBuilder class, you’ll see that WebTarget pretty much mirrors
            it. Instead of building URIs, though, WebTarget is building instances of WebTargets that
            you can use to invoke HTTP requests.

    Building and Invoking Requests
        Once you have a WebTarget that represents the exact URI you want to invoke on, you
        can begin building and invoking HTTP requests through one of its request() methods.

        Invocation.Builder has a bunch of methods that allow you to set different types of
        request headers. The various acceptXXX() methods are for content negotiation (see
        Chapter 9). The cookie() methods allow you to set HTTP cookies you want to return
        to the server. And then there are the more generic header() and headers() methods
        that cover the more esoteric HTTP headers and any custom ones your application might have.
        After setting the headers the request requires, you can then invoke a specific HTTP
        method to get back a response from the server.

        The first two generic get() methods will convert successful HTTP requests to specific
        Java types. Let’s look at these in action:
            Customer customer = client.target("http://commerce.com/customers/123")
                 .accept("application/json")
                 .get(Customer.class);

            List<Customer> customer = client.target("http://commerce.com/customers")
                .accept("application/xml")
                .get(new GenericType<List<Customer>>() {});

        In the first request we want JSON from the server, so we set the Accept header with the
        accept() method. We want the JAX-RS client to grab this JSON from the server and
        convert it to a Customer Java type using one of the registered MessageBodyReader
        components.
        The second request is a little more complicated. We have a special MessageBodyRead
        er that knows how to convert XML into List<Customer>. The reader is very sensitive
        to the generic type of the Java object, so it uses the javax.ws.rs.core.GenericType
        class to obtain information about the type. GenericType is a sneaky trick that bypasses
        Java type erasure to obtain generic type information at runtime. To use it, you create an
        anonymous inner class that implements GenericType and fill in the Java generic type
        you want to pass information about to the template parameter. I know this is a little
        weird, but there’s no other way around the Java type system.

        There’s also a get() method that returns a Response object. This is the same Re
        sponse class that is used on the server side. This gives you more fine-grained control of
        the HTTP response on the client side.

            import javax.ws.rs.core.Response;
            Response response = client.target("http://commerce.com/customers/123")
                .accept("application/json")
                .get();
                try {
                    if (response.getStatus() == 200) {
                        Customer customer = response.readEntity(Customer.class);
                    }
                } finally {
                    response.close();
                }

        In this example, we invoke an HTTP GET to obtain a Response object. We check that
        the status is OK and if so, extract a Customer object from the returned JSON document
        by invoking Response.readEntity(). The readEntity() method matches up the re‐
        quested Java type and the response content with an appropriate MessageBodyReader.

 !!!!!  Always remember to close() your Response objects. Response ob‐
        jects reference open socket streams. If you do not close them, you are
        leaking system resources. While most JAX-RS implementations im‐
        plement a finalize() method for Response, it is not a good idea to
        rely on the garbage collector to clean up poorly written code. The
        default behavior of the RESTEasy JAX-RS implementation actually
        only lets you have one open Response per Client instance. This forces
        you to write responsible client code.

        So far we haven’t discussed PUT and POST requests that submit a representation to the
        server. These types of requests have similar method styles to GET but also specify an
        entity parameter.
        The Entity class encapsulates the Java object we want to send with the POST or GET request.

        The Entity class does not have a public constructor. You instead have to invoke one
        of the static convenience methods to instantiate one:

        The xml() method takes a Java object as a parameter. It sets the MediaType to application/xml.
        The json() method acts similarly, except with JSON. The form() method
        deals with form parameters and application/x-www-form-urlencoded, and requires
        using the Form type.

        To submit form parameters, we must use the Form class:
        This class represents application/x-www-form-urlencoded in a request. Here’s an example
        of it in use:
            Form form = new Form().param("first", "Bill")
                                  .param("last", "Burke);
            response = client.target("http://commerce.com/customers")
                .request().
                .post(Entity.form(form));
            response.close();

        Invocation
            The previous examples are how you’re going to typically interact with the Client API.
            JAX-RS has an additional invocation model that is slightly different. You can create full
            Invocation objects that represent the entire HTTP request without invoking it. There’s
            a few additional methods on Invocation.Builder that help you do this

            So what is the use of this invocation style? For one, the same Invocation object can be
            used for multiple requests. Just prebuild your Invocation instances and reuse them as
            needed. Also, since invoke() is a generic method, you could queue up Invocation
            instances or use them with the execute pattern

        Exception Handling
            If the server responds with an HTTP error code not covered by a specific JAX-RS ex‐
            ception, then a general-purpose exception is thrown. ClientErrorException covers
            any error code in the 400s. ServerErrorException covers any error code in the 500s

  !!!!      This invocation style will not automatically handle server redirects—that is, when the
            server sends one of the HTTP 3xx redirection response codes. Instead, the JAX-RS
            Client API throws a RedirectionException from which you can obtain the Location
            URL to do the redirect yourself.

    Configuration Scopes
        If you look at the declarations of ClientBuilder, Client, WebTarget, Invocation, and
        Invocation.Builder, you’ll notice that they all implement the Configurable interface.
        Each one of these interfaces has its own scope of properties and registered components
        that it inherits from wherever it was created from.

            Client client = ClientBuilder.newBuilder()
             .property("authentication.mode", "Basic")
             .property("username", "bburke")
             .property("password", "geheim")
             .build();

            WebTarget target1 = client.target("http://facebook.com");
            WebTarget target2 = client.target("http://google.com")
             .property("username", "wburke")
             .register(JacksonJsonProvider.class);

        If you viewed the properties of target1 you’d find the same properties as those defined
        on the client instances, as WebTargets inherit their configuration from the Client or
        WebTarget they were created from. The target2 variable overrides the username prop‐
        erty and registers a provider specifically for target2.

        This way of configuration scoping makes it much easier for you to share initialization code so
        you can avoid creating a lot of extra objects you don’t need and reduce the amount of
        code you have to write.

    Wrapping Up
        In this chapter, we learned about the JAX-RS Client API. Client interfaces manage
        global configuration and the underlying socket connections you’ll use to communicate
        with a service. WebTarget represents a URI that you can build and invoke HTTP requests
        from. If you want to see the Client API in action, check out the numerous examples in
        Part II. They all use the Client API in some form or another.

===============================================================================================================
CHAPTER 9 - HTTP Content Negotiation

    Different clients need different formats in order to run efficiently. Java
    clients might like their data within an XML format. Ajax clients work a lot better with
    JSON. Ruby clients prefer YAML. Clients may also want internationalized data so that
    they can provide translated information to their English, Chinese, Japanese, Spanish,
    or French users. Finally, as our RESTful applications evolve, older clients need a clean
    way to interact with newer versions of our web services.

    One of its most powerful features is a client’s capability to specify to a server how it would like its
    responses formatted. The client can negotiate the content type of the message body, how
    it is encoded, and even which human language it wants the data translated into.

!!!!This protocol is called HTTP Content Negotiation, or conneg for short.

    In this chapter, I’ll explain how conneg works, how JAX-RS supports it, and most importantly how you
    can leverage this feature of HTTP within your RESTful web services.

    Conneg Explained
        The first part of HTTP Content Negotiation is that clients can request a specific media
        type they would like returned when querying a server for information. Clients set an
        Accept request header that is a comma-delimited list of preferred formats. For example:

            GET http://example.com/stuff
            Accept: application/xml, application/json

!!!!    In this example request, the client is asking the server for /stuff formatted in either
        XML or JSON. If the server is unable to provide the desired format, it will respond with
        a status code of 406, “Not Acceptable.” Otherwise, the server chooses one of the media
        types and sends a response in that format back to the client.

!!      Wildcards and media type properties can also be used within the Accept header listing.
        For example:
            GET http://example.com/stuff
            Accept: text/*, text/html;level=1
        The text/* media type means any text format

        Preference Ordering
!!!!        The protocol also has both implicit and explicit rules for choosing a media type to
            respond with. The implicit rule is that more specific media types take precedence over
            less specific ones. Take this example:
                GET http://example.com/stuff
                Accept: text/*, text/html;level=1, */*, application/xml
            The server assumes that the client always wants a concrete media type over a wildcard
            one, so the server would interpret the client preference as follows:
                1. text/html;level=1
                2. application/xml
                3. text/*
                4. */*

            The text/html;level=1 type would come first because it is the most specific. The
            application/xml type would come next because it does not have any MIME type
            properties like text/html;level=1 does. After this would come the wildcard types, with
            text/* coming first because it is obviously more concrete than the match-all qualifier */*

!!!         Clients can also be more specific on their preferences by using the qMIME type property.
            This property is a numeric value between 0.0 and 1.0, with 1.0 being the most preferred.
            For example:
                GET http://example.com/stuff
                Accept: text/*;q=0.9, */*;q=0.1, audio/mpeg, application/xml;q=0.5
 !!         If no q qualifier is given, then a value of 1.0 must be assumed. So, in our example request,
            the preference order is as follows:
                1. audio/mpeg
                2. text/*
                3. application/xml
                4. */*

    Language Negotiation
        HTTP Content Negotiation also has a simple protocol for negotiating the desired human
        language of the data sent back to the client. Clients use the Accept-Language header to
        specify which human language they would like to receive. For example:
            GET http://example.com/stuff
            Accept-Language: en-us, es, fr

        The Accept-Language header also supports preference qualifiers:
            GET http://example.com/stuff
            Accept-Language: fr;q=1.0, es;q=1.0, en=0.1
        Here, the client prefers French or Spanish, but would accept English as the default translation.

    Encoding Negotiation
        Clients can also negotiate the encoding of a message body. To save on network band‐
        width, encodings are generally used to compress messages before they are sent. The
        most common algorithm for encoding is GZIP compression. Clients use the AcceptEncoding header to specify
        which encodings they support

            GET http://example.com/stuff
            Accept-Encoding: gzip, deflate

        Here, the client is saying that it wants its response either compressed using GZIP or uncompressed (deflate).
        The Accept-Encoding header also supports preference qualifiers

 !!!    When a client or server encodes a message body, it must set the Content-Encoding
        header. This tells the receiver which encoding was used.

    JAX-RS and Conneg
        The JAX-RS specification has a few facilities that help you manage conneg. It does
        method dispatching based on Accept header values. It allows you to view this content
        information directly. It also has complex negotiation APIs that allow you to deal with
        multiple decision points. Let’s look into each of these.

        Method Dispatching
            In previous chapters, we saw how the @Produces annotation denotes which media type
            a JAX-RS method should respond with. JAX-RS also uses this information to dispatch
            requests to the appropriate Java method. It matches the preferred media types listed in
            the Accept header of the incoming request to the metadata specified in @Produces
            annotations

                (see CustomerResource from package chpt9)

            Here, we have three methods that all service the same URI but produce different data
            formats. JAX-RS can pick one of these methods based on what is in the Accept header.

        Leveraging Conneg with JAXB
            I showed you how to use JAXB annotations to map Java objects to and
            from XML and JSON. If you leverage JAX-RS integration with conneg, you can imple‐
            ment one Java method that can service both formats.

                @Produces({"application/xml", "application/json"})
                public Customer getCustomer(@PathParam("id") int id) {...}

 !!!!       In this example, our getCustomer() method produces either XML or JSON, as denoted
            by the @Produces annotation applied to it. The returned object is an instance of a Java
            class, Customer, which is annotated with JAXB annotations. Since most JAX-RS imple‐
            mentations support using JAXB to convert to XML or JSON, the information contained
            within our Accept header can pick which MessageBodyWriter to use to marshal the
            returned Java object.

        Complex Negotiation
            Unfortunately, JAX-RS does not have the notion of either an @ProduceLanguages or @ProduceEncodings
            annotation. Instead, you must code this yourself by looking at header values directly
            or by using the JAX-RS API for managing complex conneg

            In Chapter 5, you were introduced to javax.ws.rs.core.HttpHeaders, the JAX-RS
            utility interface. This interface contains some preprocessed conneg information about
            the incoming HTTP request
!!!         The getAcceptableMediaTypes() method contains a list of media types defined in
            the HTTP request’s Accept header. It is preparsed and represented as a
            javax.ws.rs.core.MediaType. The returned list is also sorted based on the “q” values
            (explicit or implicit) of the preferred media types, with the most desired listed first.

!!!         The getAcceptableLanguages() method processes the HTTP request’s AcceptLanguage header.
            It is preparsed and represented as a list of java.util.Locale objects.
            As with getAcceptableMediaTypes(), the returned list is sorted based on the “q” values
            of the preferred languages, with the most desired listed first.

                see code examples in method getRequestedMediaTypeAndLanguage from Chpt9MyService

            Variant processing
!!!             JAX-RS also has an API to dealwith situations in which you have multiple sets of media
                types, languages, and encodings you have to match against. You can use the interface
                javax.ws.rs.core.Request and the class javax.ws.rs.core.Variant to perform
                these complex mappings

                The Variant class is a simple structure that contains one media type, one language, and
                one encoding. It represents a single set that your JAX-RS resource method supports.

!!!             You’re not going to find a lot of use for the Request.selectVariant() API in the real
                world. First of all, content encodings are not something you’re going to be able to easily
                work with in JAX-RS. If you wanted to deal with content encodings portably, you’d have
                to do all the streaming yourself. Most JAX-RS implementations have automatic support
                for encodings like GZIP anyway, and you don’t have to write any code for this.
                Second, most JAX-RS services pick the response media type automatically based on the
!!              @Produces annotation and Accept header. I have never seen a case in which a given
                language is not supported for a particular media type. In most cases, you’re solely in‐
                terested in the language desired by the client. You can obtain this
                information easily through the HttpHeaders.getAcceptableLanguages() method

        Negotiation by URI Patterns
!!!             Conneg is a powerful feature of HTTP. The problem is that some clients, specifically
                browsers, do not support it. For example, the Firefox browser hardcodes the Accept
                header it sends to the web server it connects to as follows:
                    text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

                If you wanted to view a JSON representation of a specific URI through your browser,
                you would not be able to if JSON is not one of the preferred formats that your browser
                is hardcoded to accept.

                A common pattern to support such clients is to embed conneg information within the
                URI instead of passing it along within an Accept header. Two examples are:
                    /customers/en-US/xml/3323
                    /customers/3323.xml.en-US

                You could model this within your JAX-RS resource methods by creating simple path parameter
                patterns within your @Path expressions. For example:
                     @Path("/customers/{id}.{type}.{language}")
                     @GET
                     public Customer getCustomer(@PathParam("id") int id,
                                                 @PathParam("type") String type,
                                                 @PathParam("language") String language) {...}

    Leveraging Content Negotiation
!!!     Most of the examples so far in this chapter have used conneg simply to differentiate
        between well-known media types like XML and JSON. While this is very useful to help
        service different types of clients, it’s not the main purpose of conneg. Your web services
        will evolve over time. New features will be added. Expanded datasets will be offered.
        Data formats will change and evolve. How do you manage these changes? How can you
        manage older clients that can only work with older versions of your services? Modeling
        your application design around conneg can address a lot of these issues. Let’s discuss
        some of the design decisions you must make to leverage conneg when designing and
        building your applications.

        Creating New Media Types
            An important principle of REST is that the complexities of your resources are encap‐
            sulated within the data formats you are exchanging. While location information (URIs)
            and protocol methods remain fixed, data formats can evolve. This is a very important
            thing to remember and consider when you are planning how your web services are
            going to handle versioning.

            A common way to address this is to design your applications
            to define their own new media types. The convention is to combine a vnd prefix,
            the name of your new format, and a concrete media type suffix delimited by the “+”
            character. For example, let’s say the company Red Hat had a specific XML format for its
            customer database. The media type name might look like this:
                application/vnd.rht.customers+xml

!!!         The vnd prefix stands for vendor. The rht string in this example represents Red Hat
            and, of course, the customers string represents our customer database format.

            Now that we have a base media type name for the Red Hat format, we can append
            versioning information to it so that older clients can still ask for older versions of the format:
                application/vnd.rht.customers+xml;version=1.0

!!          Specifying a version property within a custom media type is a
            common pattern to denote versioning information. As this customer data format
            evolves over time, we can bump the version number to support newer clients without
            breaking older ones.

        Flexible Schemas
            Using media types to version your web services and applications is a great way to mitigate
            and manage change as your web services and applications evolve over time. While
            embedding version information within the media type is extremely useful, it shouldn’t
            be the primary way you manage change. When defining the initial and newer versions
            of your data formats, you should pay special attention to backward compatibility

            Here, we have added the street, city, state, and zip elements to our schema, but have
            made them optional. This allows older clients to still PUT and POST older, yet valid,
            versions of the data format.

            If you combine flexible, backward-compatible schemas with media type versions, you
            truly have an evolvable system of data formats. Clients that are version-aware can use
            the media type version scheme to request specific versions of your data formats. Clients
            that are not version-aware can still request and send the version of the format they
            understand.

    Wrapping Up
        In this chapter, you learned how HTTP Content Negotiation works and how you can
        write JAX-RS-based web services that take advantage of this feature. You saw how clients
        can provide a list of preferences for data format, language, and encoding. You also saw
        that JAX-RS has implicit and explicit ways for dealing with conneg. Finally, we discussed
        general architectural guidelines for modeling your data formats and defining your own
        media types.


===============================================================================================================
CHAPTER 10 - HATEOAS

    The Internet is commonly referred to as “the Web” because information is connected
    together through a series of hyperlinks embedded within HTML documents. These
    links create threads between interrelated websites on the Internet. Because of this, hu‐
    mans can “surf ” the Web for interesting tidbits of related information by clicking
    through these links with their browsers. Search engines can crawl these links and create
    huge indexes of searchable data. Without them, the Internet would never have scaled

    Besides links, another key feature of the Internet is HTML . Sometimes a website wants
    you to fill out information to buy something or register for some service. The server is
    telling you, the client, what information it needs to complete an action described on the
    web page you are viewing. The browser renders the web page into a format that you can
    easily understand. You read the web page and fill out and submit the form. An HTML
    form is an interesting data format because it is a self-describing interaction between the
    client and server

!!! The architectural principle that describes linking and form submission is called
    HATEOAS. HATEOAS stands for Hypermedia As The Engine Of Application State. It
    is a bit of a weird name for a key architecture principle, but we’re stuck with it

    The idea of HATEOAS is that your data
    format provides extra information on how to change the state of your application. On
    the Web, HTML links allow you to change the state of your browser. When you’re
    reading a web page, a link tells you which possible documents (states) you can view
    next. When you click a link, your browser’s state changes as it visits and renders a new
    web page. HTML forms, on the other hand, provide a way for you to change the state
    of a specific resource on your server.

    HATEOAS and Web Services
!!      When you’re applying HATEOAS to web services, the idea is to embed links within your XML or JSON documents.
        While this can be as easy as inserting a URL as the value of an element or attribute, most XML based RESTful
        applications use syntax from the Atom Syndication Format as a means to implement HATEOAS

            Atom is an XML-based document format that describes lists of related information
            known as “feeds.” Feeds are composed of a number of items, known as “entries,” each with
            an extensible set of attached metadata

        Think of Atom as the next evolution of RSS. It is generally used to publish blog feeds
        on the Internet, but a few data structures within the format are particularly useful for
        web services, particularly Atom links.

        Atom Links
            The Atom link XML type is a very simple yet standardized way of embedding links
            within your XML documents. Let’s look at an example:
                <customers>
                    <link rel="next"
                        href="http://example.com/customers?start=2&size=2"
                        type="application/xml"/>
                    <customer id="123">
                        <name>Bill Burke</name>
                    </customer>
                    <customer id="332">
                        <name>Roy Fielding</name>
                    </customer>
                </customers>

            The Atom link is just a simple XML element with a few specific attribute

            The rel attribute
!!!             The rel attribute is used for link relationships. It is the logical, simple name used
                to reference the link. This attribute gives meaning to the URL you are linking to,
                much in the same way that text enclosed in an HTML <a> element gives meaning
                to the URL you can click in your browser.

            The href attribute
                This is the URL you can traverse in order to get new information or change the
                state of your application.

            The type attribute
                This is the exchanged media type of the resource the URL points to.
            The hreflang attribute
                Although not shown in the example, this attribute represents the language the data
                format is translated into. Some examples are French, English, German, and Spanish.

        Advantages of Using HATEOAS with Web Services
            Machine-based clients are a little different, though. Other than browsers, there aren’t a
            lot of generic machine-based clients that know how to interpret self-describing docu‐
            ments. They can’t make decisions on the fly like humans can. They require programmers
            to tell them how to interpret data received from a service and how to transition to other
            states in the interaction between client and server. So, does that make HATEOAS useless
            to machine-based clients? Not at all. Let’s look at some of the advantages.

            Location transparency
                In a RESTful system that
                leverages HATEOAS, very few URIs are published to the outside world. Services and
                information are represented within links embedded in the data formats returned by
                accessing these top-level URIs. Clients need to know the logical link names to look for,
                but don’t have to know the actual network locations of the linked services.

                Like a naming service, links provide a level of
                indirection so that underlying services can change their locations on the network
                without breaking client logic and code. HATEOAS has an additional advantage in that
                the top-level web service has control over which links are transferred.

            Decoupling interaction details
                (for context consider that you have an API that returns all customers from the DB between a starting
                index and the number of returned rows..)

!!!             If the service changes the interface, we’ve broken older clients.
                Instead of publishing this RESTful interface for viewing our database, what if, instead,
                we embedded this information within the returned document?

                    <customers>
                        <link rel="next"
                            href="http://example.com/customers?start=2&size=2"
                            type="application/xml"/>
                        <customer id="123">
                            <name>Bill Burke</name>
                        </customer>
                        <customer id="332">
                            <name>Roy Fielding</name>
                        </customer>
                    </customers>
!!!!            By embedding an Atom link within a document, we’ve given a logical name ("next") to a state
                transition. The state transition here is the next set of customers within the database. We
                are still requiring the client to have predefined knowledge about how to interact with
                the service, but the knowledge is much simpler. Instead of having to remember which
                URI query parameters to set, all that’s needed is to follow a specific named link. The
                client doesn’t have to do any bookkeeping of the interaction. It doesn’t have to remember
                which section of the database it is currently viewing !!!

                By embedding an Atom link, we’ve decoupled a specific interaction between the client
                and server. We’ve made our web service a little more transparent and change-resistant
                because we’ve simplified the predefined knowledge the client must have to interact with
                the service. Finally, the server has the power to guide the client through interactions by
                providing links.

            Reduced state transition errors
                (for context..imagine that we want to implement the cancelling of an order for an online product)

                A better approach would be to embed a cancel link
                    <order id="333">
                         <customer id="123">...</customer>
                         <amount>$99.99</amount>
                         <cancelled>false</cancelled>
                         <link rel="cancel" href="http://example.com/orders/333/cancelled"/>
                         <order-entries>
                         ...
                         </order-entries>
                    </order>

 !!!!           The client would do a GET /orders/333 and get the XML document representing the
                order. If the document contains the cancel link, the client is allowed to change the order
                status to “cancelled” by doing an empty POST or PUT to the URI referenced in the link.
                If the document doesn’t contain the link, the client knows that this operation is not
                possible. This allows the web service to control how the client is able to interact with it
                in real time.

            W3C standardized relationships
                An interesting thing that is happening in the REST community is an effort to define,
                register, and standardize a common set of link relationship names and their associated
                behaviors

                    Table 10-1. W3C standard relationship names
                    Relationship    Description
                    previous        A URI that refers to the immediately preceding document in a series of documents.
                    next            A URI that refers to the immediately following document in a series of documents.
                    edit            A URI that can be retrieved, updated, and deleted.
                    payment         A URI where payment is accepted. It is meant as a general way to facilitate acts
                                    of payment.

                Registered relationships can go a long way to help make data formats even
                more self-describing and intuitive to work with.

        Link Headers Versus Atom Links
            Instead of embedding a link directly in your document, you can instead use Link response headers.
            This is best explained with an example.
            Consider the order cancellation example described in the previous section. An Atom
            link is used to specify whether or not the cancelling of an order is allowed and which
            URL to use to do a POST that will cancel the order. Instead of using an Atom link
            embedded within the order XML document, let’s use a Link header. So, if a user submits
            GET /orders/333, he will get back the following HTTP response:

                HTTP/1.1 200 OK
                Content-Type: application/xml
                Link: <http://example.com/orders/333/cancelled>; rel=cancel                         // the cancelation link
                <order id="333">
                 ...
                </order>

!!!!        You shouldn’t have to parse a whole XML or JSON document just to find the URL you’re interested in
            invoking on. Another nice thing is that instead of doing a GET invocation, you can do a HEAD invocation
            and avoid getting the XML document entirely. In general, I like to use Atom links for data aggregation
            and Link headers for everything else.

    HATEOAS and JAX-RS
        JAX-RS doesn’t have many facilities to help with HATEOAS. HATEOAS is defined by
        the application, so there’s not much a framework can add. What it does have, though,
        are helper classes that you can use to build the URIs that you link to in your data formats.

!!!     Building URIs with UriBuilder
            The UriBuilder class allows you to construct a URI piece by piece and is also sensitive to template parameters

            The build() methods create the actual URI. Before building the URI, though, any
            template parameters you have defined must be filled in. The build() methods take
            either a map of name/value pairs that can match up to named template parameters or
            you can provide a list of values that will replace template parameters as they appear in
            the templated URI

                (see code example in Chpt10Service)

            Another interesting example is to create a URI from the @Path expressions defined in
            a JAX-RS annotated class. (too much detail for me right now but it is nice to know that there is this option)

        Relative URIs with UriInfo
            When you’re writing services that distribute links, there’s certain information that you
            cannot know at the time you write your code. Specifically, you will probably not know
            the hostnames of the links. Also, if you are linking to other JAX-RS services, you may
            not know the base paths of the URIs, as you may be deployed within a servlet container.

!!          JAX-RS provides a cleaner, simpler way through the use of the
            javax.ws.rs.core.UriInfo interface. You were introduced to a few features of this
            interface in Chapter 5. Besides basic path information, you can also obtain UriBuild
            er instances preinitialized with the base URI used to define all JAX-RS services or the
            URI used to invoke the current HTTP request

            For example, let’s say you have a JAX-RS service that exposes the customers in a customer
            database. Instead of having a base URI that returns all customers in a document, you
            want to embed previous and next links so that you can navigate through subsections
            of the database

!!!         To get access to a UriInfo instance that represents the request, we use the @jav
            ax.ws.rs.core.Context annotation to inject it as a parameter to the JAX-RS resource
            method getCustomers()

            UriInfo also allows you to relativize a URI based on the current request URI

    Building Links and Link Headers
        JAX-RS 2.0 added some support to help you build Link headers and to embed links in
!!!     your XML documents through the Link and Link.Builder classes

        Link is an abstract class that represents all the metadata contained in either a Link header or Atom link
        The toString() method will convert the Link instance into a Link header.
        Link instances are built through a Link.Builder,

        The Link class also contains a JAXB XmlAdapter so that you can embed links within a
        JAXB class.

    Wrapping Up
        In this chapter, we discussed how links and forms have allowed the Web to scale. You
        learned the advantages of applying HATEOAS to RESTful web service design. Finally,
        you saw some JAX-RS utilities that can help make enabling HATEOAS in your JAX-RS
        services easier.


===============================================================================================================
CHAPTER 11 - Scaling JAX-RS Applications

    In this chapter, I’ll discuss some features of the Web, specifically within HTTP, that make it more scalable
    and how you can take advantage of these features within JAX-RS applications.

    Caching
        Caching is one of the more important features of the Web. When you visit a website for
        the first time, your browser stores images and static text in memory and on disk. If you
        revisit the site within minutes, hours, days, or even months, your browser doesn’t have
        to reload the data over the network and can instead pick it up locally. This greatly speeds
        up the rendering of revisited web pages and makes the browsing experience much more
        fluid. Browser caching not only helps page viewing, it also cuts down on server load. If
        the browser is obtaining images or text locally, it is not eating up scarce server bandwidth
        or CPU cycles.

!!!!    Besides browser caching, there are also proxy caches. Proxy caches are pseudo–web
        servers that work as middlemen between browsers and websites. Their sole purpose is
        to ease the load on master servers by caching static content and serving it to clients
        directly, bypassing the main servers. Content delivery networks (CDNs) like Akamai
        have made multimillion-dollar businesses out of this concept. These CDNs provide you
        with a worldwide network of proxy caches that you can use to publish your website and
        scale to hundreds of thousand of users.

!!!     If your web services are RESTful, there’s no reason you can’t leverage the caching se‐
        mantics of the Web within your applications. If you have followed the HTTP constrained
        interface religiously, any service URI that can be reached with an HTTP GET is a can‐
        didate for caching, as they are, by definition, read-only and idempotent.

        So when do you cache? Any service that provides static unchanging data is an obvious
        candidate. Also, if you have more dynamic data that is being accessed concurrently, you
        may also want to consider caching, even if your data is valid for only a few seconds or
        minutes. For example, consider the free stock quote services available on many websites.
        If you read the fine print, you’ll see that these stock quotes are between 5 and 15 minutes
        old. Caching is viable in this scenario because there is a high chance that a given quote
        is accessed more than once within the small window of validity. So, even if you have
        dynamic web services, there’s still a good chance that web caching is viable for these
        services

        HTTP Caching
            The HTTP protocol defines a rich
            set of built-in caching semantics. Through the exchange of various request and response
            headers, the HTTP protocol gives you fine-grained control over the caching behavior
            of both browser and proxy caches. The protocol also has validation semantics to make
            managing caches much more efficient. Let’s dive into the specifics.

        Expires Header
            In HTTP 1.0, a simple response header called
            Expires tells the browser that it can cache and for how long. The value of this header
            is a date in the future when the data is no longer valid. When this date is reached, the
            client should no longer use the cached data and should retrieve the data again from the
            server. For example, if a client submitted GET /customers/123, an example response
            using the Expires header would look like this:
                HTTP/1.1 200 OK
                Content-Type: application/xml
                Expires: Tue, 15 May 2014 16:00 GMT
                <customer id="123">...</customers>
            This cacheable XML data is valid until Tuesday, May 15, 2014.

        Cache-Control
!!!!        HTTP caching semantics were completely redone for the HTTP 1.1 specification. The
            specification includes a much richer feature set that has more explicit controls over
            browser and CDN/proxy caches. The idea of cache revalidation was also introduced.
            To provide all this new functionality, the Expires header was deprecated in favor of the
            Cache-Control header. Instead of a date, Cache-Control has a variable set of commadelimited directives
            that define who can cache, how, and for how long. Let’s take a look at them:
                private
                    The private directive states that no shared intermediary (proxy or CDN) is allowed
                    to cache the response. This is a great way to make sure that the client, and only the
                    client, caches the data.
                public
                    The public directive is the opposite of private. It indicates that the response may
                    be cached by any entity within the request/response chain.
                no-cache
                    Usually, this directive simply means that the response should not be cached. If it is
                    cached anyway, the data should not be used to satisfy a request unless it is revalidated
                    with the server (more on revalidation later).
                no-store
                    A browser will store cacheable responses on disk so that they can be used after a
                    browser restart or computer reboot. You can direct the browser or proxy cache to
                    not store cached data on disk by using the no-store directive.
                no-transform
                    Some intermediary caches have the option to automatically transform their cached
                    data to save memory or disk space or to simply reduce network traffic. An example
                    is compressing images. For some applications, you might want to disallow this using
                    the no-transform directive.
 !!!            max-age
                    This directive is how long (in seconds) the cache is valid. If both an Expires header
                    and a max-age directive are set in the same response, the max-age always takes precedence.
                s-maxage
                    The s-maxage directive is the same as the max-age directive, but it specifies the
                    maximum time a shared, intermediary cache (like a proxy) is allowed to hold the
                    data. This directive allows you to have different expiration times than the client.

            Let’s take a look at a simple example of a response to see Cache-Control in action:
                HTTP/1.1 200 OK
                Content-Type: application/xml
                Cache-Control: private, no-store, max-age=300
                <customers>...</customers>
            In this example, the response is saying that only the client may cache the response. This
            response is valid for 300 seconds and must not be stored on disk.

!!!!        The JAX-RS specification provides javax.ws.rs.core.CacheControl, a simple class to
            represent the Cache-Control header

            The ResponseBuilder class has a method called cacheControl() that can accept a CacheControl object
                (see code example in Chpt11CustomResource)

        Revalidation and Conditional GETs
            One interesting aspect of the caching protocol is that when the cache is stale, the cacher
            can ask the server if the data it is holding is still valid. This is called revalidation. To be
            able to perform revalidation, the client needs some extra information from the server
            about the resource it is caching. The server will send back a Last-Modified and/or an
            ETag header with its initial response to the client.

            Last-Modified
                The Last-Modified header represents a timestamp of the data sent by the server. Here’s
                an example response:
                    HTTP/1.1 200 OK
                    Content-Type: application/xml
                    Cache-Control: max-age=1000
                    Last-Modified: Tue, 15 May 2013 09:56 EST
                    <customer id="123">...</customer>
                This initial response from the server is stating that the XML returned is valid for 1,000
                seconds and has a timestamp of Tuesday, May 15, 2013, 9:56 AM EST.

                After 1,000 seconds, the client may opt to revalidate its cache of the item. To do this, it does a
                conditional GET request by passing a request header called If-Modified-Since with
                the value of the cached Last-Modified header. For example:
                    GET /customers/123 HTTP/1.1
                    If-Modified-Since: Tue, 15 May 2013 09:56 EST

!!!             When a service receives this GET request, it checks to see if its resource has been modi‐
                fied since the date provided within the If-Modified-Since header. If it has been
                changed since the timestamp provided, the server will send back a 200, “OK,” response
                with the new representation of the resource. If it hasn’t been changed, the server will
                respond with 304, “Not Modified,” and return no representation. In both cases, the
                server should send an updated Cache-Control and Last-Modified header if appropriate.

            ETag
                The ETag header is a pseudounique identifier that represents the version of the data sent
                back. Its value is any arbitrary quoted string and is usually an MD5 hash. Here’s an
                example response:
                    HTTP/1.1 200 OK
                    Content-Type: application/xml
                    Cache-Control: max-age=1000
                    ETag: "3141271342554322343200"
                    <customer id="123">...</customer>
                Like the Last-Modified header, when the client caches this response, it should also
                cache the ETag value. When the cache expires after 1,000 seconds, the client performs
                a revalidation request with the If-None-Match header that contains the value of the
                cached ETag. For example:
                    GET /customers/123 HTTP/1.1
                    If-None-Match: "3141271342554322343200"
                When a service receives this GET request, it tries to match the current ETag hash of the
                resource with the one provided within the If-None-Match header. If the tags don’t
                match, the server will send back a 200, “OK,” response with the new representation of
                the resource. If it hasn’t been changed, the server will respond with 304, “Not Modified,”
                and return no representation. In both cases, the server should send an updated CacheControl and ETag
                header if appropriate.

                One final thing about ETags is they come in two flavors: strong and weak. A strong ETag
                should change whenever any bit of the resource’s representation changes. A weak ETag
                changes only on semantically significant events. Weak ETags are identified with a W/
                prefix.

!!!!            JAX-RS has a simple class called javax.ws.rs.core.EntityTag that represents the ETag header

            JAX-RS and conditional GETs
                To help with conditional GETs, JAX-RS provides an injectable helper class called jav
                ax.ws.rs.core.Request

                    (see code example in Chpt11..)

                An instance of javax.ws.rs.core.Request is in‐
                jected into the method using the @Context annotation. We then find a Customer instance
                and create a current ETag value for it from the hash code of the object (this isn’t the best
                way to create the EntityTag, but for simplicity’s sake, let’s keep it that way). We then
                call Request.evaluatePreconditions(), passing in the up-to-date tag. If the tags
                match, we reset the client’s cache expiration by sending a new Cache-Control header
                and return. If the tags don’t match, we build a Response with the new, current version
                of the ETag and Customer.

    Concurrency
        we need to look at how to scale applications that update resources
        on our server. The way RESTful updates work is that the client fetches a representation
!!!!    of a resource through a GET request. It then modifies the representation locally and
        PUTs or POSTs the modified representation back to the server. This is all fine and dandy
        if there is only one client at a time modifying the resource, but what if the resource is
        being modified concurrently?
        Because the client is working with a snapshot, this data could become stale if another client
        modifies the resource while the snapshot is being processed.

        The HTTP specification has a solution to this problem through the use of conditional
        PUTs or POSTs. This technique is very similar to how cache revalidation and conditional
        GETs work. The client first starts out by fetching the resource. For example, let’s say our
        client wants to update a customer in a RESTful customer directory. It would first start
        off by submitting GET /customers/123 to pull down the current representation of the
        specific customer it wants to update. The response might look something like this

            HTTP/1.1 200 OK
            Content-Type: application/xml
            Cache-Control: max-age=1000
            ETag: "3141271342554322343200"
            Last-Modified: Tue, 15 May 2013 09:56 EST
            <customer id="123">...</customer>

!!!!    In order to do a conditional update, we need either an ETag or Last-Modified head‐
        er. This information tells the server which snapshot version we have modified when we
        perform our update. It is sent along within the If-Match or If-Unmodified-Since
        header when we do our PUT or POST request. The If-Match header is initialized with
        the ETag value of the snapshot. The If-Unmodified-Since header is initialized with the
        value of Last-Modified header. So, our update request might look like this:
            PUT /customers/123 HTTP/1.1
            If-Match: "3141271342554322343200"
            If-Unmodified-Since: Tue, 15 May 2013 09:56 EST
            Content-Type: application/xml
            <customer id="123">...</customer>

        You are not required to send both the If-Match and If-Unmodified-Since headers.
        One or the other is sufficient to perform a conditional PUT or POST. When the server
        receives this request, it checks to see if the current ETag of the resource matches the
        value of the If-Match header and also to see if the timestamp on the resource matches
        the If-Unmodified-Since header. If these conditions are not met, the server will return
        an error response code of 412, “Precondition Failed.” This tells the client that the rep‐
        resentation it is updating was modified concurrently and that it should retry. If the
        conditions are met, the service performs the update and sends a success response code
        back to the client.

            (see code example in Chpt11... updateConcurrently)

        The updateCustomer() method obtains a customer ID and an instance of jav
        ax.ws.rs.core.Request from the injected parameters. It then locates an instance of a
        Customer object in some application-specific way (for example, from a database). From
        this current instance of Customer, it creates an EntityTag from the hash code of the
        object. It also finds the current timestamp of the Customer instance in some application specific way.
        The Request.evaluatePreconditions() method is then called with time
        stamp and tag variables. If these values do not match the values within the If-Match
        and If-Unmodified-Since headers sent with the request, evaluatePreconditions()
        sends back an instance of a ResponseBuilder initialized with the error code 412, “Pre‐
        condition Failed.” A Response object is built and sent back to the client. If the precon‐
        ditions are met, the service performs the update and sends back a success code of 204,
        “No Content.”
        With this code in place, we can now worry less about concurrent updates of our re‐
        sources. One interesting thought is that we did not have to come up with this scheme
        ourselves. It is already defined within the HTTP specification. This is one of the beauties
        of REST, in that it fully leverages the HTTP protocol.

    Wrapping Up
        In this chapter, you learned that HTTP has built-in facilities to help scale the perfor‐
        mance of our distributed systems. HTTP caching is a rich protocol that gives us a lot of
        control over browser, proxy, and client caches. It helps tremendously in reducing net‐
        work traffic and speeding up response times for applications. Besides caching, dis‐
        tributed systems also have the problem of multiple clients trying to update the same
        resource. The HTTP protocol again comes to the rescue with well-defined semantics
        for handling concurrent updates
        For both caching and concurrent updates, JAX-RS
        provides some helper classes to make it easier to enable these features in your Java
        applications


===============================================================================================================
CHAPTER 12 - Filters and Interceptors

Filters and interceptors are objects that are able to interpose themselves on client or
server request processing. They allow you to encapsulate common behavior that cuts
across large parts of your application. This behavior is usually infrastructure- or
protocol-related code that you don’t want to pollute your business logic with.
This chapter teaches you how to write filters and interceptors using real-world examples.


    Server-Side Filters
!!!     On the server side there are two different types of filters: request filters and response
        filters. Request filters execute before a JAX-RS method is invoked. Response filters ex‐
        ecute after the JAX-RS method is finished. By default they are executed for all HTTP
        requests, but can be bound to a specific JAX-RS method too

!!!     For those of you familiar with the Servlet API, JAX-RS filters are quite different. JAXRS breaks up its
        filters into separate request and response interfaces, while servlet filters
        wrap around servlet processing and are run in the same Java call stack. Because JAXRS has an asynchronous
        API, JAX-RS filters cannot run in the same Java call stack. Each
        request filter runs to completion before the JAX-RS method is invoked. Each response
        filter runs to completion only after a response becomes available to send back to the client.

        Server Request Filters
!!!         Request filters are implementations of the ContainerRequestFilter interface

            ContainerRequestFilters come in two flavors: prematching and postmatching. Pre‐
            matching ContainerRequestFilters are designated with the @PreMatching annota‐
            tion and will execute before the JAX-RS resource method is matched with the incoming
            HTTP request. Prematching filters often are used to modify request attributes to change
            how they match to a specific resource. For example, some firewalls do not allow PUT
            and/or DELETE invocations. To circumvent this limitation, many applications tunnel
            the HTTP method through the HTTP

            Filters can modify pretty much anything about the incoming request through
            methods on ContainerRequestContext, but once the request is matched to a JAX-RS
            method, a filter cannot modify the request URI or HTTP method.

            Another great use case for request filters is implementing custom authentication protocols.
            For example, OAuth 2.0 has a token protocol that is transmitted through the Authorization HTTP header
                (see class BearerTokenFilter in code examples)

        Server Response Filters
!!!         Response filters are implementations of the ContainerResponseFilter interface

            Generally, you use these types of filters to decorate the response by adding or modifying
            response headers. One example is if you wanted to set a default Cache-Control header
            for each response to a GET request.

            The ContainerResponseFilter.filter() method has two parameters. The Contain
            erRequestContext parameter gives you access to information about the request. Here
            we’re checking to see if the request was a GET. The ContainerResponseContext pa‐
            rameter allows you to view, add, and modify the response before it is marshalled and
            sent back to the client.

    Reader and Writer Interceptors
!!!     While filters modify request or response headers, reader and writer interceptors deal
        with message bodies. They work in conjunction with a MessageBodyReader or MessageBodyWriter
        and are usable on both the client and server. Reader interceptors implement
        the ReaderInterceptor interface. Writer interceptors implement the WriterInterceptor interface.

        These interceptors are only triggered when a MessageBodyReader or MessageBodyWrit
        er is needed to unmarshal or marshal a Java object to and from the HTTP message body.
        They also are invoked in the same Java call stack. In other words, a ReaderIntercep
        tor wraps around the invocation of MessageBodyReader.readFrom() and a WriterIn
        terceptor wraps around the invocation of MessageBodyWWriter.writeTo().

        A simple example that illustrates these interfaces in action is adding compression to
        your input and output streams through content encoding
            (example is in the book. i find this too be too detailed for me right now)

        There’s a lot of other use cases for interceptors that I’m not going to go into detail with.
        For example, the RESTEasy project uses interceptors to digitally sign and/or encrypt
        message bodies into a variety of Internet formats. You could also use a WriterInterceptor
        to add a JSONP wrapper to your JSON content. A ReaderInterceptor could
        augment the unmarshalled Java object with additional data pulled from the request or
        response. The rest is up to your imagination.

    Client-Side Filters
        The JAX-RS Client API also has its own set of request and response filter interfaces:
            ClientRequestFilter
            ClientResponseFilter

        Let’s use these two interfaces to implement a client-side cache. We want this cache to
        behave like a browser’s cache. This means we want it to honor the Cache-Control
        semantics discussed in Chapter 11. We want cache entries to expire based on the met‐
        adata within Cache-Control response headers. We want to perform conditional GETs
        if the client is requesting an expired cache entry

            (example is in the book...this is useful for a Client app / Integration tests)

    Deploying Filters and Interceptors
        On the server side, filters and interceptors are deployed the same way any other @Pro
        vider is deployed. You either annotate it with @Provider and let it be scanned and
        automatically registered, or you add the filter or interceptor to the Application class’s
        classes or singletons list.     (I had to do both...maybe because i am in DevMode running of the Server)

        On the client side, you register filters and interceptors the same way you would register
        any other provider. There are a few components in the Client API that implement the
        Configurable interface. This interface has a register() method that allows you to pass
        in your filter or interceptor class or singleton instance. ClientBuilder, Client, and
        WebTarget all implement the Configurable interface

    Ordering Filters and Interceptors
        When you have more than one registered filter or interceptor, there may be some sen‐
        sitivities on the order in which these components are executed. For example, you usually
        don’t want unauthenticated users executing any of your JAX-RS components. So, if you
        have a custom authentication filter, you probably want that filter to be executed first.
        Another example is the combination of our GZIP encoding example with a separate
        WriterInterceptor that encrypts the message body. You probably don’t want to encrypt
        a GZIP-encoded representation. Instead you’ll want to GZIP-encode an encrypted rep‐
        resentation. So ordering is important.

!!!!    In JAX-RS, filters and interceptors are assigned a numeric priority either through the
        @Priority annotation or via a programmatic interface defined by Configurable. The
        JAX-RS runtime sorts filters and interceptors based on this numeric priority. Smaller
        numbers are first in the chain

!!!    If no priority is specified, the default is USER, 5000

    Per-JAX-RS Method Bindings
        On the server side, you can apply a filter or interceptor on a per-JAX-RS-method basis.
        This allows you to do some really cool things like adding annotation extensions to your
        JAX-RS container. There are two ways to accomplish this. One is by registering an
        implementation of the DynamicFeature interface. The other is through annotation
        binding. Let’s look at DynamicFeature first.

        DynamicFeature
            The DynamicFeature interface has one callback method, configure(). This config
            ure() method is invoked for each and every deployed JAX-RS method. The Resour
            ceInfo parameter contains information about the current JAX-RS method being de‐
            ployed. The FeatureContext is an extension of the Configurable interface. You’ll use
            the register() methods of this parameter to bind the filters and interceptors you want
            to assign to this method.

            To illustrate how you’d use DynamicFeature, let’s expand on the CacheControlFilter
            response filter we wrote earlier in this chapter. The previous incarnation of this class
            would set the same Cache-Control header value for each and every HTTP request. Let’s
            modify this filter and create a custom annotation called @MaxAge that will allow you to
            set the max-age of the Cache-Control header per JAX-RS method:

            Notice that we do not annotate CacheControlFilterMaxAge with @Provider. Removing @Provider will prevent
            this filter from being picked up on a scan when we deploy our JAX-RS application.

        Name Bindings
            The other way to bind a filter or interceptor to a particular JAX-RS method is to use the
            @NameBinding meta-annotation

            You can bind a filter or interceptor to a particular annotation and when that custom
            annotation is applied, the filter or interceptor will automatically be bound to the anno‐
            tated JAX-RS method. Let’s take our previous BearerTokenFilter example and bind to
            a new custom @TokenAuthenticated annotation.

            Notice that @TokenAuthenticated is annotated with @NameBinding. This tells the JAXRS runtime that this
            annotation triggers a specific filter or interceptor.

        DynamicFeature Versus @NameBinding
!!!!        To be honest, I’m not a big fan of @NameBinding and lobbied for its removal from early
            specification drafts. For one, any application of @NameBinding can be reimplemented
            as a DynamicFeature. Second, using @NameBinding can be pretty inefficient depending
            on your initialization requirements

    Exception Processing
        So what happens if a filter or interceptor throws an exception? On the server side, the
        JAX-RS runtime will process exceptions in the same way as if an exception were thrown
        in a JAX-RS method. It will try to find an ExceptionMapper for the exception and then
        run it. If an exception is thrown by a ContainerRequestFilter or ReaderInterceptor
        and mapped by an ExceptionMapper, then any bound ContainerResponseFilter
        must be invoked. The JAX-RS runtime ensures that at most one ExceptionMapper
         will be invoked in a single request processing cycle. This avoids infinite loops.

        On the client side, if the exception thrown is an instance of WebApplicationExcep
        tion, then the runtime will propagate it back to application code. Otherwise, the ex‐
        ception is wrapped in a javax.ws.rs.client.ProcessingException if it is thrown
        before the request goes over the wire. The exception is wrapped in a javax.ws.rs.cli
        ent.ResponseProcessingException when processing a response.

    Wrapping Up
!!      In this chapter we learned about client- and server-side filters and interceptors. Filters
        generally interact with HTTP message headers, while interceptors are exclusive to pro‐
        cessing HTTP message bodies. Filters and interceptors are applied to all HTTP requests
        by default, but you can bind them to individual JAX-RS resource methods by using
        DynamicFeature or @NameBinding


===============================================================================================================
CHAPTER 13 - Asynchronous JAX-RS

Another interesting new feature introduced in JAX-RS 2.0 is asynchronous request and
response processing both on the client and server side. If you are mashing together a
lot of data from different websites or you have something like a stock quote application
that needs to push events to hundreds or thousands of idle blocking clients, then the
JAX-RS 2.0 asynchronous APIs are worth looking into.

    AsyncInvoker Client API
        The client asynchronous API allows you to spin off a bunch of HTTP requests in the
        background and then either poll for a response, or register a callback that is invoked
        when the HTTP response is available. To invoke an HTTP request asynchronously on
        the client, you interact with the javax.ws.rs.client.AsyncInvoker interface or the
        submit() methods on javax.ws.rs.client.Invocation. First, let’s take a look at poll‐
        ing HTTP requests that are run in the background.

        Using Futures
!!!!        The AsyncInvoker interface has a bunch of methods that invoke HTTP requests
            asynchronously and that return a java.util.concurrent.Future instance. You can use the
            AsyncInvoker methods by invoking the async() method on the Invocation.Builder interface.

            The Future interface is defined within the java.util.concurrent package that comes
            with the JDK. For JAX-RS, it gives us a nice reusable interface for polling HTTP re‐
            sponses in either a blocking or nonblocking manner. If you’ve used java.util.concur
            rent.Executors or @Asynchronous within an EJB container, using the Future interface
            should be very familiar to you

            This is best explained in a full example:
                (see code examples from chpt13 packages, in production and test code)

                After executing both requests, we poll and block indefinitely on future1 by calling Future.get() until we
                get a Response back from that service. With future2, we instead poll and block for five seconds only...
                java.util.concurrent.TimeoutException is thrown if the call
                takes longer than five seconds. You can also invoke the nonblocking isDone() or is
                Cancelled() methods on Future to see if the request is finished or cancelled.

                Exceptions that can be thrown by Future.get() methods are defined by that interface.
                java.util.concurrent.TimeoutException occurs if we are calling Future.get() with
                a timeout. InterruptedException happens if the calling thread has been interrupted.
                java.util.concurrent.ExecutionException is a wrapper exception. Any exception
                thrown by the JAX-RS runtime is caught and wrapped by this exception.

                You can obtain any exception thrown by the JAX-RS runtime when an asynchronous
                request is executed by calling the ExecutionException.getCause() method. The pos‐
                sible wrapped JAX-RS exceptions are the same as the synchronous ones discussed in
                Chapter 8

!!!!!           You should always make sure that the underlying JAX-RS response is
                closed. While most JAX-RS containers will have their Response ob‐
                jects implement a finalize() method, it is not a good idea to rely on
                the garbage collector to clean up your client connections. If you do not
                clean up your connections, you may end up with intermittent errors
                that pop up if the underlying Client or operating system has exhaus‐
                ted its limit of allowable open connections

        Using Callbacks
            The AsyncInvoker interface has an additional callback invocation style. You can register
            an object that will be called back when the asynchronous invocation is ready for processing

            The InvocationCallback interface is a parameterized generic interface and has two
            simple methods you have to implement—one for successful responses, the other for
            failures:

                    public interface InvocationCallback<RESPONSE> {
                        public void completed(RESPONSE response);
                        public void failed(Throwable throwable);
                    }
            (see code examples from package chpt13)
            The CustomerCallback class implements InvocationCallback with a Response generic
             parameter. This means JAX-RS will call the completed() method and pass in an
            untouched Response object. If there is a problem sending the request to the server or
            the JAX-RS runtime is unable to create a Response, the failed() method will be invoked
            with the appropriate exception. Otherwise, if there is an HTTP response, then completed()
            will be called

            How about if we have something like this:
                public class OrderCallback implements InvocationCallback<Order>

            This case is a little bit different than when we implement InvocationCallback with a
            Response. If there is a successful HTTP response from the server (like 200, “OK”), JAXRS will attempt to
            unmarshal the response into an Order object. If there were an HTTP
            error response, or the JAX-RS runtime failed to unmarshal the response body into an
            Order object, then the failed() method is invoked with the appropriate exception.
            Basically, we see the same kind of exceptions thrown by similar synchronous invocations
            or the Future example we discussed earlier.
      !!!   You do not have to close the underlying
            Response object; JAX-RS will do this after completed() or failed() is invoked.

        Futures Versus Callbacks
!!!         Given that we have two different ways to do asynchronous client invocations, which
            style should you use? Futures or callbacks? In general, use futures if you need to join a
            set of requests you’ve invoked asynchronously. By join, I mean you need to know when
            each of the requests has finished and you need to perform another task after all the
            asynchronous requests are complete. For example, maybe you are gathering informa‐
            tion from a bunch of different web services to build a larger aggregated document (a
            mashup).
!!!         Use callbacks when each invocation is its own distinct unit and you do not have to do
            any coordination or mashing up.


    Server Asynchronous Response Processing
        For a typical HTTP server, when a request comes in, one thread is dedicated to the
        processing of that request and its HTTP response to the client. This is fine for the vast
        majority of HTTP traffic both on the Internet and on your company’s internal networks.
        Most HTTP requests are short-lived, so a few hundred threads can easily handle a few
        thousand concurrent users and have relatively decent response times.

        The nature of HTTP traffic started to change somewhat as JavaScript clients started to
        become more prevalent. One problem that popped up often was the need for the server
        to push events to the client. A typical example is a stock quote application where you
        need to update a string of clients with the latest stock price. These clients would make
        an HTTP GET or POST request and just block indefinitely until the server was ready
        to send back a response. This resulted in a large amount of open, long-running requests
        that were doing nothing other than idling. Not only were there a lot of open, idle sockets,
        but there were also a lot of dedicated threads doing nothing at all. Most HTTP servers
        were designed for short-lived requests with the assumption that one thread could pro‐
        cess requests from multiple concurrent users. When you have a very large number of
        threads, you start to consume a lot of operating system resources. Each thread consumes
        memory, and context switching between threads starts to get quite expensive when the
        OS has to deal with a large number of threads. It became really hard to scale these types
        of server-push applications since the Servlet API, and by association JAX-RS, was a “one
        thread per connection” model.

        In 2009, the Servlet 3.0 specification introduced asynchronous HTTP. With the Servlet
        3.0 API, you can suspend the current server-side request and have a separate thread,
        other than the calling thread, handle sending back a response to the client. For a serverpush app, you could
         then have a small handful of threads manage sending responses
        back to polling clients and avoid all the overhead of the “one thread per connection”
        model. JAX-RS 2.0 introduced a similar API that we’ll discuss in this section.

!!!!!    Server-side async response processing is only meant for a specific small
        subset of applications. Asynchronous doesn’t necessarily mean auto‐
        matic scalability. For the typical web app, using server asynchronous
        response processing will only complicate your code and make it hard‐
        er to maintain. It may even hurt performance

        AsyncResponse API
            To use server-side async response processing, you interact with the AsyncResponse interface

            You get access to an AsyncResponse instance by injecting it into a JAX-RS method using
            the @Suspended annotation

            When you inject an instance of AsyncResponse using the
            @Suspended annotation, the HTTP request becomes suspended from the current thread
            of execution.

            This background thread processes (i modified the code ...it doesn't do any processing but it could).
            It then sends a response back to the client by calling the resume() method, passing in the response value/
            instance. Invoking resume() in this manner means that it is a successful
            response. So, a status code of 200 is sent back to the client. Also, because we’re
            passing a Java object, the resume() method will marshal this object and send it within
            the HTTP response body. The media type used is determined by the @Produces anno‐
            tation placed on the original JAX-RS method. If the @Produces annotation has more
            than one value, then the request’s Accept header is examined to pick the returned media
            type. Basically, this is the same algorithm a regular JAX-RS method uses to determine
            the media type.

            Finally, the previous example is pretty simple, but what if it were possible for orderPro
            cessor.process() to throw an exception? We can handle this exception by using the
            AsyncResponse.resume(Throwable) method.
            Invoking AsyncResponse.resume(Throwable) is like throwing an exception from a
            regular synchronous JAX-RS method. Standard JAX-RS exception handling is per‐
            formed on the passed-in Throwable. If a matching ExceptionMapper exists for the
            passed-in Throwable, it will be used. Otherwise, the server will send back a 500 status code.

        Status Methods
            There’s a few status methods on AsyncResponse that specify the state of the response:
                public interface AsyncResponse {
                     boolean isSuspended();
                     boolean isCancelled();
                     boolean isDone();
                     ...
                }
            The AsyncResponse.isCancelled() method can be called to see if a AsyncResponse
            has been cancelled. isSuspended() specifies whether or not the response can have resume()

        Timeouts
            If an AsyncResponse is not resumed or cancelled, it will eventually time out. The default
            timeout is container-specific. A timeout results in a 503, “Service Unavailable,” response
            code sent back to the client. You can explicitly set the timeout by invoking the setTimeout() method:
            response.setTimeout(5, TimeUnit.SECONDS);

        Callbacks
            The AsyncResponse interface also allows you to register callback objects for other types of events:
                package javax.ws.rs.container;
                public interface CompletionCallback {
                    public void onComplete(Throwable throwable);
                }
            CompletionCallback.onComplete() is called after the response has been sent to the
            client. The Throwable is set to any unmapped exception thrown internally when processing
            a resume(). Otherwise, it is null.
                package javax.ws.rs.container;
                public interface ConnectionCallback {
                    public void onDisconnect(AsyncResponse response);
                }

!!!!!       You enable callbacks by invoking the AsyncResponse.register() methods. You can
            pass one or more classes that will be instantiated by the JAX-RS container, and you can
            pass one or more instances:
                response.register(MyCompletionCallback.class);
                response.register(new MyConnectionCallback());
            Callbacks are generally used to receive notification of error conditions caused after
            invoking resume(). You may have resources to clean up or even transactions to roll back
            or undo as a result of an asynchronous failure.

        Use Cases for AsyncResponse
            Server-side push
                With server-side push, the server is sending events back to the client. A typical example
                is stock quotes. The client wants to be notified when a new quote is available. It does a
                long-poll GET request until the quote is ready

                The preceding continuously polls for a quote using InvocationCallback. On the server
                side, we want our JAX-RS resource classes to use suspended requests so that we can
                have one thread that writes quotes back to polling clients. With one writer thread, we
                can scale this quote service to thousands and thousands of clients, as we’re not beholden
                to a “one thread per request” model.

            Publish and subscribe
                Another great use case for AsyncResponse is publish and subscribe applications, an
                example being a chat service. Here’s what the server code might look like:

                This is a really poor chat implementation, as messages could be lost for clients that are
                repolling, but hopefully it illustrates how you might create such an application. In
                Chapter 27, we’ll implement a more robust and complete chat service.

  !!!!!         With protocols like WebSocket1 and Server Sent Events (SSE)2 being
                supported in most browsers, pure HTTP server push and pub-sub are
                fast becoming legacy. So, if you’re only going to have browser clients
                for this kind of app, you’re probably better off using WebSockets or SSE.

            Priority scheduling
                Sometimes there are certain services that are highly CPU-intensive. If you have too
                many of these types of requests running, you can completely starve users who are mak‐
                ing simple, fast requests. To resolve this issue, you can queue up these expensive requests
                in a separate thread pool that guarantees that only a few of these expensive operations
                will happen concurrently

                        (see code changes in PriorityScheduling)

                that calculates buying patterns for a specific product for the year to date. We want to
                allow only one of these requests to execute at a time, as the calculation is extremely
                expensive. We set up a single-threaded java.util.concurrent.Executor in the Order
                Resource constructor. The ytdReport() method queues up a Runnable in this Execu
                tor that generates the report and sends it back to the client. If the Executor is currently
                busy generating a report, the request is queued up and executed after that report is
                finished.

    Wrapping Up
        In this chapter, we discussed how you can use JAX-RS asynchronously both on the client
        and server side. On the client, you can execute one or more requests in the background
        and either poll for their response, or receive a callback. On the server, we saw that you
        can suspend requests so that a different thread can handle response processing. This is
        a great way to scale specific kinds of applications. Chapter 27 walks you through a bunch
        of code examples that show most of these features in action.


===============================================================================================================
CHAPTER 14 - Deployment and Integration

Throughout this book, I have focused on teaching you the basics of JAX-RS and REST
with simple examples that have very few moving parts. In the real world, though, your
JAX-RS services are going to interact with databases and a variety of server-side com‐
ponent models. They will need to be secure and sometimes transactional. Chapter 3was
a very simple example of deploying JAX-RS within a Java EE environment. In this
chapter, we’ll look into more deployment details of JAX-RS and how it integrates with
Java EE and other component models

    Deployment
        JAX-RS applications are deployed within a standalone servlet container, like Apache
        Tomcat, Jetty, JBossWeb, or the servlet container of your favorite application server, like
        JBoss, Wildfly, Weblogic, Websphere, or Glassfish. Think of a servlet container as a web
        server. It understands the HTTP protocol and provides a low-level component model
        (the servlet API) for receiving HTTP requests.

        Servlet-based applications are organized in deployment units called Web ARchives
        (WAR). A WAR is a JAR-based packaging format that contains the Java classes and
        libraries used by the deployment as well as static content like images and HTML files
        that the web server will publish. Here’s what the structure of a WAR file looks like:
            <any static content>
            WEB-INF/
                web.xml
                classes/
                lib/

        Any files outside and above the WEB-INF/ directory of the archive are published and
        available directly through HTTP. This is where you would put static HTML files and
        images that you want to expose to the outside world. The WEB-INF/ directory has two
        subdirectories. Within the classes/ directory, you can put any Java classes you want.
        The lib/ directory can contain any application or
        third-party libraries that will be used by the deployment. The WEB-INF/ directory also
        contains a web.xml deployment descriptor file. This file defines the configuration of the
        WAR and how the servlet container should initialize it.

        You will need to define a web.xml file for your JAX-RS deployments.
            (Dan this is not accurate anymore..)

        How JAX-RS is deployed within a servlet container varies between JAX-RS-aware (like within Java EE
        application servers or standalone Servlet 3.x containers like Tomcat) and older JAXRS–unaware servlet
        containers. Let’s dive into these details


        The Application Class       (Dan in this project the ShoppingApplication extends Application and is the one doing the registering)
            The Application class is the only portable way of telling JAX-RS which web services
            (@Path annotated classes) as well as which filters, interceptors,
            MessageBodyReaders, MessageBodyWriters, and ContextResolvers (providers) you want deployed.

!!!!!       The Application class is very simple. All it does is list classes and objects that JAX-RS
            is supposed to deploy. The getClasses() method returns a list of JAX-RS web service
            and provider classes. JAX-RS web service classes follow the per-request model mentioned in Chapter 3.
!!!!        Provider classes are instantiated by the JAX-RS container and registered once per application.
            The getSingletons() method returns a list of preallocated JAX-RS web services and
            providers. You, as the application programmer, are responsible for creating these objects
            When these objects are registered, JAX-RS will also inject values for @Context annotated fields and
            setter methods.

        Deployment Within a JAX-RS-Aware Container
            Java EE stands for Java Enterprise Edition. It is the umbrella specification of JAX-RS
            and defines a complete enterprise platform that includes services like a servlet container,
            EJB, transaction manager (JTA), messaging (JMS), connection pooling (JCA), database
            persistence (JPA), web framework (JSF), and a multitude of other services. Application
            servers that are certified under Java EE 6 are required to have built-in support for JAXRS 1.1.
            Java EE 7  containers are required to have built-in support for JAX-RS 2.0.

            Deploying a JAX-RS application is very easy in a JAX-RS-aware servlet container. You
            still need at least an empty web.xml file
                (Dan...not needed anymore it seems..)

            If you have at least one Application class implementation annotated with @ApplicationPath,
            the JAX-RS–aware container will automatically deploy that Application.

            @ApplicationPath("/root")
            The @ApplicationPath annotation here will set up a base path to whatever the WAR’s
            context root is, with "root" appended.

!!!!        When scanning, the application server will look within WEB-INF/classes and any JAR
            file within the WEB-INF/lib directory. It will add any class annotated with @Path or
            @Provider to the list of things that need to be deployed and registered with the JAX-RS
            runtime. You can also deploy as many Application classes as you want in one WAR.
            The scanner will also ignore any Application classes not annotated with @ApplicationPath.

            You can also override the @ApplicationPath annotation via a simple servlet mapping
            within web.xml

        Deployment Within a JAX-RS-Unaware Container
            If you are running in 2.x or older Servlet containers, you’ll have to manually configure
            your web.xml file to load your JAX-RS implementation’s proprietary servlet class.
                (see book for more details on this)

    Configuration
        Your RESTful web services will probably need to sit in front of a database and interact with
        other local and remote services. Your services will also need configuration settings that
        are described outside of code. I don’t want to get into too much detail, but the servlet
        and Java EE specifications provide annotations and XML configurations that allow you
        to get access to various Java EE services and configuration information. Let’s look at
        how JAX-RS can take advantage of these features.

!!!!    Any JAX-RS implementation, whether it sits within a JAX-RS-aware or Java EE container,
        must support the @Context injection of the javax.servlet.ServletContext
        and javax.servlet.ServletConfig interfaces. Through these interfaces, you can get
        access to configuration information expressed in the WAR’s web.xml deployment descriptor

        In this web.xml file, we want to define a default maximum dataset size for a JAX-RS–
        based customer database that returns a collection of customers through XML. We do
        this by defining a <context-param> named max-customers-size and set the value to
        10. We can get access to this value within our JAX-RS service by injecting a reference
        to ServletContext with the @Context annotation.

            (see code example from Chpt14Resource)
!!!     Here, we use the @Context annotation on the setServletContext() method of our
        CustomerResource class. When an instance of CustomerResource gets instantiated, the
        setServletContext() method is called with access to a javax.servlet.ServletCon
        text. From this, we can obtain the value of max-customers-size that we defined in our
        web.xml and save it in the member variable defaultPageSize for later use.

!!!     Another way you might want to do this is to use your javax.ws.rs.core.Application
        class as a factory for your JAX-RS services. You could define or pull in configuration
        information through this class and use it to construct your JAX-RS service.

        We first remove all references to the ServletContext injection we did in our previous
        incarnation of the CustomerResource class. We replace it with a setter method, setDe
        faultPageSize(), which initializes the defaultPageSize member variable. This is a
        better design for our CustomerResource class because we’ve abstracted away how it
        obtains configuration information. This gives the class more flexibility as it evolves over
        time.
        We then inject the ServletContext into our Application class and extract the needed
        information to initialize our services

    EJB Integration
        EJBs are Java EE components that help you write business logic more easily. They sup‐
        port integration with security, transactions, and persistence

        Java EE requires that EJB containers support integration with JAX-RS. You are allowed to use
        JAX-RS annotations on local interfaces or no-interface beans of stateless session or
        singleton beans. No other integration with other bean types is supported.

        If you are using the full-scanning deployment mechanism I mentioned before, you can
        just implement your services and put the classes of your EJBs directly within the WAR,
        and JAX-RS will find them automatically. Otherwise, you have to return the bean class
        of each JAX-RS EJB from your Application.getClasses() method

    Spring Integration
        Spring is an open source framework similar to EJB. Like EJB, it provides a great ab‐
        straction for transactions, persistence, and security.

        Most JAX-RS implementations have their own proprietary support for Spring and allow you to write
        Spring beans that are JAX-RS web services. If portability is not an issue for you, I suggest
        that you use the integration with Spring provided by your JAX-RS implementation.

        (more info on this subject in the book...I might revisit it after learning more about Spring)

    Wrapping Up
        In this chapter, you learned how deployment works within Java EE and standalone
        Servlet 3.x containers as well as in environments that are JAX-RS aware. We also looked
        at some portable ways to configure your JAX-RS applications. Finally, you saw how you
        can portably integrate with EJB and Spring. Chapter 28 will allow you to test-drive some
        of the concepts presented in this chapter. It will walk you through the deployment of a
        full application that integrates with EJB, Spring, and Java Persistence (JPA).


===============================================================================================================
CHAPTER 15 - Securing JAX-RS

Many RESTful web services will want secure access to the data and functionality they
provide. This is especially true for services that will be performing updates. They will
want to prevent sniffers on the network from reading their messages. They may also
want to fine-tune which users are allowed to interact with a specific service and disallow
certain actions for specific users. The Web and the umbrella specification for JAX-RS,
Java EE, provide a core set of security services and protocols that you can leverage from
within your RESTful web services. These include:

!!!
Authentication
    Authentication is about validating the identity of a client that is trying to access
    your services. It usually involves checking to see if the client has provided an existing
    user with valid credentials, such as a password. The Web has a few standardized
    protocols you can use for authentication. Java EE, specifically your servlet container,
    has facilities to understand and configure these Internet security authentication
    protocols

!!!
Authorization
    Once a client is authenticated, it will want to interact with your RESTful web service.
    Authorization is about deciding whether or not a certain user is allowed to access
    and invoke on a specific URI. For example, you may want to allow write access
    (PUT/POST/DELETE operations) for one set of users and disallow it for others.
    Authorization is not part of any Internet protocol and is really the domain of your
    servlet container and Java EE.

!!!
Encryption
    When a client is interacting with a RESTful web service, it is possible for hostile
    individuals to intercept network packets and read requests and responses if your
    HTTP connection is not secure. Sensitive data should be protected with crypto‐
    graphic services like SSL. The Web defines the HTTPS protocol to leverage SSL and
    encryption.

JAX-RS has a small programmatic API for interacting with servlet and Java EE security,
but enabling security in a JAX-RS environment is usually an exercise in configuration
and applying annotation metadata

This chapter first focuses on the various web protocols used for authentication in a
standard, vanilla Java EE, and servlet environment. You’ll learn how to configure your
JAX-RS applications to use standard authentication, authorization, and encryption.
Next you’ll learn about various formats you can use to digitally sign or encrypt message
bodies. Finally, we’ll talk about the OAuth protocol and how you can use it within your
applications.

    Authentication
        When you want to enforce authentication for your RESTful web services, the first thing
        you have to do is decide which authentication protocol you want to use. Internet pro‐
!!!!    tocols for authentication vary in their complexity and their perceived reliability. In Java
        land, most servlet containers support the protocols of Basic Authentication, Digest Authentication
        and authentication using X.509 certificates

!!!     Basic Authentication
            Basic Authentication is the simplest protocol available for performing authentication
            over HTTP. It involves sending a Base 64–encoded username and password within a
            request header to the server. The server checks to see if the username exists within its
            system and verifies the sent password.

            Example:
            Say an unauthorized client tries to access one of our secure RESTful web services:
                GET /customers/333 HTTP/1.1
            Since the request does not contain any authentication information, the server would
            reply with an HTTP response of:
                HTTP/1.1 401 Unauthorized
                WWW-Authenticate: Basic realm="CustomerDB Realm"
            The 401 response tells the client that it is not authorized to access the URI it tried to invoke on.
!!!         The WWW-Authenticate header specifies which authentication protocol the client should use.
            In this case, Basic means Basic Authentication should be used. The
            realm attribute identifies a collection of secured resources on a website. The client can
            use the realm information to match against a username and password that is required
            for this specific URI.

!!          To perform authentication, the client must send a request with the Authorization
            header set to a Base 64–encoded string of our username and a colon character, followed
            by the password. If our username is bburke and our password geheim, the Base 64–
            encoded string of bburke:geheim will be YmJ1cmtlOmdlaGVpbQ==. Put all this together,
            and our authenticated GET request would look like this:
                GET /customers/333 HTTP/1.1
                Authorization: Basic YmJ1cmtlOmdlaGVpbQ==
!!          The client needs to send this Authorization header with each and every request it makes
            to the server.

!!!         The problem with this approach is that if this request is intercepted by a hostile entity
            on the network, the hacker can easily obtain the username and password and use it to
            invoke its own requests. Using an encrypted HTTP connection, HTTPS, solves this
            problem. With an encrypted connection, a rogue programmer on the network will be
            unable to decode the transmission and get at the Authorization header. Still, security paranoid network
            administrators are very squeamish about sending passwords over the
            network, even if they are encrypted within SSL packets.

!!!     Digest Authentication
            Although not used much anymore, Digest Authentication was invented so that clients
            would not have to send clear-text passwords over HTTP. It involves exchanging a set of
            secure MD5 hashes of the username, password, operation, URI, and optionally the hash
            of the message body itself.

                (Example is presented in the book...)

!!          One advantage of this approach is that the password is never used directly by the pro‐
            tocol. For example, the server doesn’t even need to store clear-text passwords. It can
            instead initialize its authorization store with prehashed values. Also, since request hash‐
            es are built with a nonce value, the server can expire these nonce values over time. This,
            combined with a request counter, can greatly reduce replay attacks.

!!          The disadvantage to this approach is that unless you use HTTPS, you are still vulnerable
            to man-in-the-middle attacks, where the middleman can tell a client to use Basic Au‐
            thentication to obtain a password.

!!!     Client Certificate Authentication
            When you buy things or trade stocks on the Internet, you use the HTTPS protocol to
            obtain a secure connection with the server. HTTPS isn’t only an encryption
            mechanism—it can also be used for authentication. When you first interact with a secure
            website, your browser receives a digitally signed certificate from the server that identifies
            it. Your browser verifies this certificate with a central authority like VeriSign. This is
            how you guarantee the identity of the server you are interacting with and make sure
            you’re not dealing with some man-in-the-middle security breach

!!!         HTTPS can also perform two-way authentication. In addition to the client receiving a
            signed digital certificate representing the server, the server can receive a certificate that
            represents and identifies the client. When a client initially connects to a server, it ex‐
            changes its certificate and the server matches it against its internal store. Once this link
            is established, there is no further need for user authentication, since the certificate has
            already positively identified the user.

!!          Client Certificate Authentication is perhaps the most secure way to perform authenti‐
            cation on the Web. The only disadvantage of this approach is the managing of the cer‐
            tificates themselves. The server must create a unique certificate for each client that wants
            to connect to the service. From the browser/human perspective, this can be a pain, as
            the user has to do some extra configuration to interact with the server.

    Authorization
!!!     authorization is about permissions. Is my user allowed to perform the operation it is invoking? None of
        the standards-based Internet authorization protocols discussed so far deals with au‐
        thorization. The server and application know the permissions for each user and do not
        need to share this information over a communication protocol. This is why authoriza‐
        tion is the domain of the server and application.

        JAX-RS relies on the servlet and Java EE specifications to define how authorization
!!      works. Authorization is performed in Java EE by associating one or more roles with a
        given user and then assigning permissions based on that role. While an example of a
        user might be “Bill” or “Monica,” roles are used to identify a group of users—for instance,
        “adminstrator,” “manager,” or “employee.” You do not assign access control on a per user basis, but rather on
        a per-role basis.

    Authentication and Authorization in JAX-RS
        To enable authentication, you need to modify the WEB-INF/web.xml deployment de‐
        scriptor of the WAR file your JAX-RS application is deployed in. You enable authori‐
!!!     zation through XML or by applying annotations to your JAX-RS resource classes.

        We want to secure our customer service so that only
        administrators are allowed to create new customers. Let’s look at a full XML-based
        implementation of this example
            (see web.xml for code changes..)

        The <login-config> element defines how we want our HTTP requests to be authen‐
        ticated for our entire deployment. The <auth-method> subelement can be BASIC, DIGEST
        or CLIENT_CERT. These values correspond to Basic, Digest, and Client Certificate
        Authentication, respectively.

        The <login-config> element doesn’t turn on authentication. By default, any client can
        access any URL provided by your web application with no constraints. To enforce au‐
        thentication, you must specify a URL pattern you want to secure. In our example, we
        use the <url-pattern> element to specify that we want to secure the /services/
        customers URL. The <http-method> element says that we only want to secure POST
        requests to this URL. If we leave out the <http-method> element, all HTTP methods
        are secured. In our example, we only want to secure POST requests, so we must define
        the <http-method> element.

        Next, we have to specify which roles are allowed to POST to /services/customers. In
        the web.xml file example, we define an <auth-constraint> element within a <security-constraint>.
        This element has one or more <role-name> elements that
        define which roles are allowed to access the defined constraint.

        If you set a <role-name> of * instead, any user would be able to access the constrained
        URL. Authentication with a valid user would still be required, though. In other words,
        a <role-name> of * means anybody who is able to log in can access the resource.

        For every <role-name> we use in our <auth-constraints> declarations, we must define a
        corresponding <security-role> in the deployment descriptor.

        The <url-pattern> element does not have as rich an expression syntax
        as JAX-RS @Path annotation values. In fact, it is extremely limited. It supports only
        simple wildcard matches via the * character. No regular expressions are supported
            Example:
                • /*
                • /foo/*
                • *.txt

        The wildcard pattern can only be used at the end of a URL pattern or to match file
        extensions. When used at the end of a URL pattern, the wildcard matches every character
        in the incoming URL. For example, /foo/* would match any URL that starts
        with /foo

        Enforcing Encryption
            By default, the servlet specification will not require access over HTTPS to any user
            constraints you declare in your web.xml file. If you want to enforce HTTPS access for
            these constraints, you can specify a <user-data-constraint> within your <securityconstraint> definitions

!!      Authorization Annotations
            Java EE defines a common set of annotations that can define authorization metadata.
            The JAX-RS specification suggests, but does not require, vendor implementations to
            support these annotations in a non–Java EE 6 environment. These annotations live in
            the javax.annotation.security package and are @RolesAllowed, @DenyAll, @Permi
            tAll, and @RunAs.

            The @RolesAllowed annotation defines the roles permitted to execute a specific oper‐
            ation. When placed on a JAX-RS annotated class, it defines the default access control
            list for all HTTP operations defined in the JAX-RS class. If placed on a JAX-RS method,
            the constraint applies only to the method that is annotated.
            The @PermitAll annotation specifies that any authenticated user is permitted to invoke
            your operation. As with @RolesAllowed, you can use this annotation on the class to
            define the default for the entire class or you can use it on a per-method basis.

            Our CustomerResource class is annotated with @RolesAllowed to specify that, by de‐
            fault, only ADMIN and CUSTOMER users can execute HTTP operations and paths defined
            in that class. The getCustomer() method is not annotated with any security annotations,
            so it inherits this default behavior. The createCustomer() method is annotated with
            @RolesAllowed to override the default behavior. For this method, we only want to allow
            ADMIN access. The getCustomers() method is annotated with @PermitAll. This
            overrides the default behavior so that any authenticated user can access that URI and
            operation.

!!!!!!      In practice, I don’t like to specify security metadata using annotations. Security generally
            does not affect the behavior of the business logic being executed and falls more under
            the domain of configuration. Administrators may want to add or remove role con‐
            straints periodically. You don’t want to have to recompile your whole application when
            they want to make a simple change. So, if I can avoid it, I usually use web.xml to define
            my authorization metadata.

!!!!        There are some advantages to using annotations, though. For one, it is a workaround
            for doing fine-grained constraints that are just not possible in web.xml because of the
            limited expression capabilities of <url-pattern>. Also, because you can apply con‐
            straints per method using these annotations, you can fine-tune authorization per media
            type.

    Programmatic Security
        The security features defined in this chapter have so far focused on declarative security
        metadata, or metadata that is statically defined before an application even runs. JAXRS also has a small
        programmatic API for gathering security information about a se‐
        cured request. Specifically, the javax.ws.rs.core.SecurityContext interface has a
        method for determining the identity of the user making the secured HTTP invocation.
!!!         public interface SecurityContext {
                 public Principal getUserPrincipal();
                 public boolean isUserInRole(String role);
                 public boolean isSecure();
                 public String getAuthenticationScheme();
            }

        The getAuthenticationScheme() tells you which authentication mechanism was used to
        secure the request. BASIC, DIGEST, CLIENT_CERT, and FORM are typical values returned
        by this method. You get access to a SecurityContext instance by injecting it into a field,
        setter method, or resource method parameter using the @Context annotation.

    Client Security
        The JAX-RS 2.0 specification didn’t do much to define a common client security API.
        What’s weird is that while it has a stardard API for rarely used protocols like two-way
        SSL with client certificates, it doesn’t define one for simple protocols like . Instead, you
        have to rely on the vendor implementation of JAX-RS to provide these security features.
        For example, the RESTEasy framework provides a ContainerRequestFilter you can
        use to enable Basic Authentication:

            import org.jboss.resteasy.client.jaxrs.BasicAuthentication;

            Client client = Client.newClient();
            client.register(new BasicAuthentication("username", "password"));

        You construct the BasicAuthentication filter with the username and password you
        want to authenticate with. That’s it. Other JAX-RS implementations might have other
        mechanisms for doing this.

        Verifying the Server
            HTTPS isn’t only about encrypting your network connection, it is also about establish‐
            ing trust. One aspect of this on the client side is verifying that the server you are talking
            to is the actual server you want to talk to and not some middleman on the network that
            is spoofing it. With most secure Internet servers, you do not have to worry about es‐
            tablishing trust because the server’s certificates are signed by a trusted authority like
            VeriSign, and your JAX-RS client implementation will know how to verify certificates
            signed by these authorities.
            In some cases, though, especially in test environments, you may be dealing with servers
            whose certificates are self-signed or signed by an unknown authority. In this case, you
            must obtain a truststore that contains the server certificates you trust and register them
            with the Client API. The ClientBuilder has a method for this:
                abstract class ClientBuilder {
                 public abstract ClientBuilder trustStore(final KeyStore trustStore);
                }
            How you initialize and populate the KeyStore is beyond the scope of this book.

    OAuth 2.0
!!!     OAuth 2.0 is an authentication protocol that allows an entity to gain access to a user’s
        data in a secure manner without having to know the user’s credentials.1
        A typical example is a news site like cnn.com. You’re reading an interesting political editorial and
        want to voice your opinion on the article in its comment section. To do this, though,
        you have to tell CNN who you are and what your email address is. It gives you the option
        of logging in via your Google or Facebook account. You are forwarded to Google and
        log in there. You grant CNN permission to ask Google who you are and what your email
        address is, and then you are forwarded back to cnn.com so that you can enter in your
        comment. Through this interaction CNN is granted an access token, which it then uses
        to obtain information about you via a seperate HTTP request.

        Here’s how it works:
            1. The CNN website redirects your browser to Google’s login page. This redirect sets
                a special cnn.com session cookie that contains a randomly generated value. The
                redirect URL contains client_id, state, and redirect_uri. The client_id is the
                Google username CNN has registered with Google.com. The state parameter is
                the same value that was set in the session cookie. The redirect_uri is a URL you
                want Google to redirect the browser back to after authentication. A possible redirect
                URL in this scenario thus would be http://googleapis.com/oauth?cli
                ent_id=cnn&state=23423423123412352314&redirect_uri=http%3A%2F%2Fcnn.com.
            2. You enter your username and password on Google’s login page. You then are asked
                if you will grant CNN access to your personal information.
            3. If you say yes, Google generates an access code and remembers the client_id and
                redirect_uri that was sent in the original browser redirect.
            4. Google redirects back to CNN.com using the redirect_uri sent by CNN’s initial
                redirect. The redirect URL contains the original state parameter you forwarded
                along with a code parameter that contains the access code: http://cnn.com/
                state=23423423123412352314&code=0002222.
            5. With this redirection, CNN will also get the value of the special cookie that it set in
                step 1. It checks the value of this cookie with the state query parameter to see if
                they match. It does this check to make sure that it initiated the request and not some
                rogue site.
            6. The CNN server then extracts the code query parameter from the redirect URL. In
                a separate authenticated HTTP request to Google, it posts this access code. Google.com
                authenticates that CNN is sending the request and looks up the access code
                that was sent. If everything matches up, it sends back an access token in the HTTP
                response.
            7. CNN can now make HTTP requests to other Google services to obtain information
                it wants. It does this by passing the token in an Authorization header with a value
                of Bearer plus the access token. For example:
                    GET /contacts?user=billburke
                    Host: contacts.google.com
                    Authorization: Bearer 2a2345234236122342341bc234123612341234123412adf

!!      In reality, sites like Google, Facebook, and Twitter don’t use this protocol exactly. They
        all put their own spin on it and all have a little bit different way of implementing this
        protocol
        This is because the
!!!     OAuth specification is more a set of detailed guidelines rather than a specific protocol
        set in stone

        There are many different Java frameworks out there that can help you turn your appli‐
        cations into OAuth providers or help you integrate with servers that support OAuth
        authentication. This is where I make my own personal plug. In 2013, I started a new
!!      project at Red Hat called Keycloak. It is a complete end-to-end solution for OAuth and
        SSO. It can also act as a social broker with social media sites like Google and Facebook
        to make leveraging social media easier. Please check us out at http://www.keycloak.org

    Signing and Encrypting Message Bodies
        Digital Signatures
            Java developers are intimately familiar with the HashMap class. The way maps work is
            that a semi-unique hash code is generated for the key you are storing in the map. The
            key’s hash code is used as an array index to quickly look up a value in the map. Under
            the covers, a digital signature is simply an encrypted hash code of the piece of data you
            are transmitting.
            While a shared secret can be used to generate and verify a digital signature, the best
            approach is to use an asymmetric key pair: in other words, a private and public key

            The signer creates the digital signature of the message using its private key. It then publishes
            its public key to the world. The receiver of the message uses the public key to verify the
            signature. If you use the right hash and encryption algorithms, it is virtually impossible
            to derive the private key of the sender or fake the signatures. I’m going to go over two
            methods you can use to leverage digital signatures in your RESTful web services.

            DKIM/DOSETA

            JOSE JWS
                JOSE JSON Web Signature is a self-contained signature format that contains both the
                message you want to sign as well as the digital signature of the message.
                The format is completely text-based and very compact. It consists of three Base 64–encoded strings
                delimited by a . character. The three encoded strings in the JOSE JWS format are a
                JSON header describing the message, the actual message that is being transmitted, and
                finally the digital signature of the message. The media type for JOSE JWS is application/jose+json

            https://auth0.com/blog/how-to-explain-public-key-cryptography-digital-signatures-to-anyone/

    Wrapping Up
        In this chapter, we discussed a few of the authentication protocols used on the Internet
        —specifically, Basic, Digest, and Client Certificate Authentication. You learned how to
        configure your JAX-RS applications to be secure using the metadata provided by the
        servlet and Java EE specifications. You also learned about OAuth as well as digital sig‐
        natures and encryption of HTTP messages. Chapter 29 contains some code you can use
        to test-drive many of the concepts in this chapter.

===============================================================================================================
CHAPTER 16 - Alternative Java Clients

While JAX-RS 2.0 added client support, there are other Java clients you can use to
interact with web services if you do not have JAX-RS 2.0 available in your environment.

    java.net.URL
        Like most programming languages, Java has a built-in HTTP client library. It’s nothing
        fancy, but it’s good enough to perform most of the basic functions you need. The API
        is built around two classes, java.net.URL and java.net.HttpURLConnection

            (see JavaURLTest class)

!!!!    By default, HttpURLConnectionwill cache results based on the caching response headers
        discussed in Chapter 11. You must invoke HttpURLConnection.setUseCaches(false)
        to turn off this feature.

        The HttpURLConnection class supports Basic, Digest, and Client Certificate Authenti‐
        cation. Basic and Digest Authentication use the java.net.Authenticator API

        The weirdest part of the API is that it is driven by the static method setDefault(). The
        problem with this is that your Authenticator is set VM-wide. So, doing authenticated
        requests in multiple threads to different servers is a bit problematic with the basic ex‐
        ample just shown. You can address this by using java.lang.ThreadLocal variables to
        store username and passwords

        Client Certificate Authentication
            (also possible...too detailed for now)

!!!     Advantages and Disadvantages
            The biggest advantage of using the java.net package as a RESTful client is that it is built
            in to the JDK. You don’t need to download and install a different client framework.

            There are a few disadvantages to the java.net API. First, it is not JAX-RS–aware. You
            will have to do your own stream processing and will not be able to take advantage of
            any of the MessageBodyReaders and MessageBodyWriters that come with your JAXRS implementation.

            Second, the framework does not do preemptive authentication for Basic or Digest Au‐
            thentication. This means that HttpURLConnection will first try to invoke a request
            without any authentication headers set. If the server requires authentication, the initial
            request will fail with a 401, “Unauthorized,” response code. The HttpURLConnection
            implementation then looks at the WWW-Authenticate header to see whether Basic or
            Digest Authentication should be used and retries the request. This can have an impact
            on the performance of your system because each authenticated request will actually be
            two requests between the client and server.

            Third, the framework can’t do something as simple as form parameters. All you have
            to work with are java.io.OutputStream and java.io.InputStream to perform your
            input and output.

    Apache HttpClient
        Although it is not JAX-RS–aware, it does have facilities for preemptive authentication and APIs for
        dealing with a few different media types like forms and multipart. Some of its other
        features are a full interceptor model, automatic cookie handling between requests, and
        pluggable authentication

        Advantages and Disadvantages
            Apache HttpClient is a more complete solution and is better designed than
            java.net.HttpURLConnection. Although you have to download it separately from the
            JDK, I highly recommend you take a look at it. It has none of the disadvantages of
            HttpURLConnection, except that it is not JAX-RS–aware. Many JAX-RS implementa‐
            tions, including RESTEasy, allow you to use Apache HttpClient as the underlying HTTP
            client engine, so you can get the best of both worlds.


    RESTEasy Client Proxies
        The RESTEasy Client Proxy Framework is a different way of writing RESTful Java cli‐
        ents. The idea of the framework is to reuse the JAX-RS annotations on the client side.
        When you write JAX-RS services, you are using the specification’s annotations to turn
        an HTTP invocation into a Java method call. The RESTEasy Client Proxy Framework
        flips this around to instead use the annotations to turn a method call into an HTTP
        request.

        Advantages and Disadvantages
            A nice side effect of writing Java clients with this proxy framework is that you can use
            the Java interface for Java clients and JAX-RS services. With one Java interface, you also
            have a nice, clear way of documenting how to interact with your RESTful Java service.
            As you can see from the example code, it also cuts down on a lot of boilerplate code.
            The disadvantage, of course, is that this framework, while open source, is proprietary.

    Wrapping Up
        In this chapter, you learned three alternative ways to write RESTful clients in Java using
        the JDK’s java.net.HttpURLConnection class, Apache HttpClient, and the RESTEasy
        Client Proxy Framework. All three have their merits as alternatives to the JAX-RS 2.0
        Client API.


===============================================================================================================
CHAPTER 17 - Workbook Introduction

    The following workbook chapters were designed to be a companion to the main chapters of
    this book. Their goal is to provide step-by-step instructions for installing, configuring,
    and running various JAX-RS examples found throughout this book with the RESTEasy
    framework.

    I picked RESTEasy as the JAX-RS framework for the workbook for no other reason than I am
    the project lead for it and I know it backward and forward


===============================================================================================================
CHAPTER 18 - Examples for Chapter 3

    If you were  building this WAR file to be deployed on the JBoss or Wildfly application servers, you
    would not want to include all of these RESTEasy dependencies within the WAR file.
    This is because these application servers already come with JAX-RS preinstalled. In this
    case, you would define a scope of provided for each of the other dependencies listed in this file.

!!! The build element contains configuration information related to how Maven should
    build our project. The first item we have under this section is the finalName element.
    This element overrides the default file naming conventions of Maven. Here we’re stating
    that we want our WAR file to be named ex03_1.war.

===============================================================================================================
CHAPTER 19 - Examples for Chapter 4

    (nothing to add ..i did the Service Locator example in chpt4 package and added other methods in chpt3 package
    regarding various expressions in @Path annotation)

===============================================================================================================
CHAPTER 20 - Examples for Chapter 5

    (nothing to add here ...i added code examples with most of the features described in chapter 5)

===============================================================================================================
CHAPTER 21 - Examples for Chapter 6

    For our Application class, we need to register the JavaMarshaller class. If we don’t,
    the JAX-RS runtime won’t know how to handle the application/example-java media
    type. (!!! this means if you write a custom marshaller that you need to register it in the main Application
    class)

===============================================================================================================
CHAPTER 22 - Examples for Chapter 7

    The last thing we have to do is modify our Application class to register the Exception
    Mapper:
        public ShoppingApplication()
         {
            singletons.add(new CustomerResource());
            classes.add(CustomerNotFoundExceptionMapper.class);
         }

    !!!!! So exceptionMappers need to be registered just like other service classes


===============================================================================================================
CHAPTER 23 - Examples for Chapter 9

    Nothing special that wasn't covered in chapter 9 already...

===============================================================================================================
CHAPTER 24 - Examples for Chapter 10

    The first is the use of Link headers within a RESTful application. The second is that if your services
    provide the appropriate links, you only need one published URL to navigate through
    your system. When you look at the client code for this example, you’ll see that only one
    URL is hardcoded to start the whole process of the example.

    Dan there is a very nice/complete example in this chapter in part with the Link Header

    an example with a cancel link in the header

        protected void addCancelHeader(UriInfo uriInfo, Response.ResponseBuilder builder)
         {
             UriBuilder absolute = uriInfo.getAbsolutePathBuilder();
             URI cancelUrl = absolute.clone().path("cancel").build();
             builder.links(Link.fromUri(cancelUrl).rel("cancel").build());
         }

         @POST
         @Path("{id}/cancel")
         public void cancelOrder(@PathParam("id") int id)
         {
             Order order = orderDB.get(id);
             if (order == null)
             {
                throw new WebApplicationException(Response.Status.NOT_FOUND);
             }
             order.setCancelled(true);
         }

!!! One of the things I want to illustrate with this example is that a client needs to be aware
    of only one URL to navigate through the entire system. The StoreResource class is the
    base URL of the system and publishes Link headers to the relevant services of the
    application

    This class accepts HTTP HEAD /shop requests and publishes the customers and or
    ders link relationships. These links point to the services represented by the Customer
    Resource and OrderResource classes.

    All URLs are accessed via Link headers or Atom links (in this example)



===============================================================================================================
CHAPTER 25 - Examples for Chapter 11

!!!!!
    One should make sure to implement hashCode for objects that they want to use with ETag headers...

!!
    While a hash code calculated in this manner isn’t guaranteed to be unique,
    there is a high probability that it will be. A database application might use an incre‐
    mented version column to calculate the ETag value.


===============================================================================================================
CHAPTER 26 - Examples for Chapter 12


===============================================================================================================
CHAPTER 27 - Examples for Chapter 13

    In Chapter 13, you learned how clients can invoke HTTP requests in the background.
    You also learned how the server side can detach response processing from the original
    calling thread with an AsyncResponse. In this chapter, we’ll use both of these features
    to implement a customer chat service.

        Explications for ChatClient and ChatServer are in the book.


===============================================================================================================
CHAPTER 28 - Examples for Chapter 14

    In this chapter, there are two similar examples that define the
    services illustrated in Chapter 2. The first marries JAX-RS with EJB. The second uses
    Spring to write our JAX-RS services. Instead of using in-memory maps like the earlier
    examples in the workbook, both examples use the Java Persistence API (JPA) to map
    Java objects to a relational database.

        (the Spring example seems more interesting as Spring is still widely used today...not sure about EJBs
        ..So..most likely I would do it after learning about Spring..)

    EJB and JAX-RS
        Like all of our previous examples, the JAXB classes that define our XML
        data format live in the com.restfully.shop.domain package. A separate parallel Java
        package, com.restfully.shop.persistence, was created for the example’s JPA classes.
        These JPA classes are almost a carbon copy of the JAXB ones, except they are using JPA
        annotations to map to a relational database.

!!!!    You could use JAXB and JPA annotations together within one class hierarchy, but this
        isn’t the best idea, as there are a few problems you might encounter. The first has to do
        with how JPA works. Objects like the OrderEntity have relationships to other classes
        like LineItemEntity, ProductEntity, and CustomerEntity. In JPA, it is common to
        lazy-load these objects as their object graphs are traversed. This can save on database
        access time. The problem where JAX-RS is concerned is that the JAX-RS runtime will
        usually turn the Java object into an XML document outside the scope of an EJB request.
        This might cause lazy-load exceptions when JAXB tries to traverse the entire object
        graph.

!!!     You can write your code so that it is careful not to introduce lazy-load exceptions, but
        there is one other major problem you may encounter. You will often want to support
        older clients that use older versions of the XML format. This can cause a divergence
        between your XML schema and your database schema. The best way to avoid this prob‐
        lem is to create two separate class hierarchies. That way, your XML and database map‐
        pings can evolve separately from one another. Yes, it’s a little more code for you to write,
        but it will save you headaches in the long run

        Our EJB class is annotated with the @javax.ejb.Stateless annotation to mark it as a
        stateless session EJB. The CustomerResourceBean class implements the CustomerRe
        source interface.
        There is a javax.persistence.EntityManager field named em. The annotation @jav
        ax.persistence.PersistenceContext injects an instance of the EntityManager into
        that field. The EntityManager persists Java objects into a relational database. These are
        all facilities of EJB and JPA

!!!!    Next, the code executes the query. You can see that doing paging is a little bit easier with
        JPA than the in-memory database we used in Chapter 24. The setMaxResults() and
        query.setFirstResult() methods set the index and size of the dataset you want
        returned.

!!!     The EntityManager.getReference() method is used by various EJBs in this example
        to locate objects within the database. When this method cannot find an object within
        the database, it throws a javax.persistence.EntityNotFoundException. If we de‐
        ployed this code as is, JAX-RS would end up eating this exception and returning a 500,
        “Internal Server Error,” to our clients if they tried to access an unknown object in the
        database. The 404, “Not Found,” error response code makes a lot more sense to return
        in this scenario. To facilitate this, a JAX-RS ExceptionMapper is used

    Spring and JAX-RS
!!!     There isn’t much difference between the code of ex14_1 and ex14_2. The Java classes
        are basically the same, except all the EJB @Stateless annotations were removed from
        the JAX-RS resource classes because the example is using Spring instead of EJB for its
        component model.

        Besides the removal of EJB metadata, the differences between the two projects are
        mainly packaging and configuration. If you look through the ex14_2 directory, you’ll
        see that we’re back to using embedded Jetty. The web.xml file is a tiny bit different than
        the EJB example,

        The getSingletons() method is responsible for initializing Spring and registering any
        JAX-RS resource beans created by Spring with the JAX-RS runtime. It first looks up the
        name of the Spring XML configuration file. The filename is stored in a servlet context’s
        init parameter named spring-beans-file. The getSingletons() method looks up this
        init parameter via the injected ServletContext.

===============================================================================================================
CHAPTER 29 - Examples for Chapter 15

    The chapter goes over some example code that illustrates a few of the concepts and APIs
    you were introduced to in Chapter 15. In the first example, you’ll write two custom
    security plug-ins. In the second example, you’ll use JSON Web Encryption to add more
    security to a chat application.



    Allowed-per-Day Access Policy
        The next custom security feature we’ll implement is an allowed-per-day access policy.
        The idea is that for a certain JAX-RS method, we’ll specify how many times each user
        is allowed to execute that method per day. We will do this by applying the @Allowed
        PerDay annotation to a JAX-RS method

        (see code examples)

    In Chapter 15, you learned a little bit about JSON Web Encryption (JWE) and how it
    can be used to encrypt HTTP message body or header values. This example augments
    the customer chat client implemented in Chapter 27. Chat clients will use a shared secret
    to encrypt and decrypt the messages they send to and receive from the chat server. Chat
    clients that know the shared secret see the decrypted message, while clients that don’t
    know it see only the JWE encoding
        (will need another dependency to do this example...i just had a look over it)

    One thing to notice is that we have not changed the server at all (as in the class ChatServer). The server is a dumb
    intermediary that just forwards messages from one client to others. It doesn’t care about
    what is being sent across the wire.


!!!!!!!!!
the code examples here are using the RESTEasy implementation, as I am using the feature:
    <feature>restfulWS-3.0</feature>
for more details check out this :
    https://openliberty.io/docs/latest/reference/jaxrs-dif.html
this page is also useful for understanding the differences between JAX-RS 2.0 and 3.0

TODO Do a readme page with all the important notes from the book

TODO / Nice to know when in need
    Chapter 24 the part with the Link Header (i already did a method)...that is a nice HATEOAS rather complete example..
    "The OrderResource class is used to create, post, and cancel orders in our ecommerce
     system. The purge operation is also available to destroy any leftover order entries that
     have been cancelled but not removed from the order entry database"

     basically only a starting link is offered and then the client can navigate the app by using Link headers or Atom links